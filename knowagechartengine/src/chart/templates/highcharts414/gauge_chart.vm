#set($dataFields = $data.metaData.fields) ## columns of data table
#set($dataColumnsMapper = {})

#foreach ($dataField in $dataFields) ## conversion column name to internal column name
	#if($dataField.class.name == 'java.util.LinkedHashMap')
		#set($workAroundNoPrint = $dataColumnsMapper.put($dataField.header , $dataField.name))
	#end
#end

#set($rows = $data.rows) ## data in table rows

#set($series = $chart.VALUES.SERIE) ## metadata related to series

#set($seriesMap = {}) ## conversion series metadata to map object
#if($series.class.name == 'java.util.LinkedHashMap')
	#set($workAroundNoPrint = $seriesMap.put($series.name , $series))
#else
	#foreach($serie in $series)
		#set($workAroundNoPrint = $seriesMap.put($serie.name , $serie))
	#end
#end

{
    chart: {
   		type: 'gauge',

		#*
			This parameter must be set to false, since if not defined
			in the case where we have more than one Y-axis ticks on lines 
			will have wrong values.
			
			@author: danristo (danilo.ristovski@mht.net)
		*#
		alignTicks: false,

   		#if($chart.style.backgroundColor != '')
   		backgroundColor: '$chart.style.backgroundColor', ##outer chart background
    	#end
   		
   		#if($chart.height != '')
    	height:'$chart.height',
    	#end
    	
    	#if($chart.width != '')
    	width:'$chart.width',
    	#end

        plotBackgroundColor: null,
        plotBorderWidth: 0,
        plotShadow: false
    },
    
    title: {
        text: '$chart.TITLE.text',
        
        #set ($titleAlign = $chart.TITLE.style.align)
        #if ($titleAlign != '' )
        
        	#if ($titleAlign == 'left')
        	x: 70,
        	#elseif ($titleAlign == 'right')
        	x: -70,
        	#end
        
        align: '$titleAlign',
        #end
        
        style:{
        #foreach($styleName in $chart.TITLE.style.keySet())
        	#set ($axisTytleStyle = $chart.TITLE.style[$styleName])
    		#if ($styleName == 'fontWeight' && ($axisTitleStyle == 'italic' || $axisTitleStyle == 'normal'))
    			fontStyle: '$axisTitleStyle',
			#elseif($styleName == 'fontWeight' && $axisTytleStyle == 'underline')
    			textDecoration: 'underline',
			#else		        			
    			$styleName: '$axisTytleStyle',
    		#end
		#end
	    }
    },
    
    #if($chart.SUBTITLE.text != '')
    subtitle: {
        text: '$chart.SUBTITLE.text',
        
        #set ($subtitleAlign = $chart.SUBTITLE.style.align)
        #if ($subtitleAlign != '' )
        
        	#if ($subtitleAlign == 'left')
        	x: 70,
        	#elseif ($subtitleAlign == 'right')
        	x: -70,
        	#end
        
        align: '$subtitleAlign',
        #end
        
        style:{
        #foreach($styleName in $chart.SUBTITLE.style.keySet())
        	#set ($axisSubtitleStyle = $chart.SUBTITLE.style[$styleName])
    		#if ($styleName == 'fontWeight' && ($axisSubtitleStyle == 'italic' || $axisSubtitleStyle == 'normal'))
    			fontStyle: '$axisSubtitleStyle',
			#elseif($styleName == 'fontWeight' && $axisSubtitleStyle == 'underline')
    			textDecoration: 'underline',
			#else		        			
    			$styleName: '$axisSubtitleStyle',
    		#end
		#end
		}
    },
    #end

    pane: {    
        
    	#if($chart.PANE.startAngle)
        	startAngle: $chart.PANE.startAngle,
        #end
        #if($chart.PANE.endAngle)
        	endAngle: $chart.PANE.endAngle,
        #end
        
        background: [
        {
            backgroundColor: {
                linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
                stops: [[0, '#FFF'],[1, '#333']]
            },
            borderWidth: 0,
            outerRadius: '109%'
        }, {
            backgroundColor: {
                linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
                stops: [
                    [0, '#333'],
                    [1, '#FFF']
                ]
            },
            borderWidth: 1,
            outerRadius: '107%'
        }, {
            // default background
        }, {
            backgroundColor: '#DDD',
            borderWidth: 0,
            outerRadius: '105%',
            innerRadius: '103%'
        }]
    },
    
    #set($axisList = {})
    #if($chart.AXES_LIST.AXIS.class.name == 'java.util.ArrayList')
    	#set($axisList = $chart.AXES_LIST.AXIS)
    #else
    	#set($axis = $axisList.put($axis.id , $chart.AXES_LIST.AXIS))
    #end
    
 	#set($counterYAxis = 0) 
 	#set($counterYAxisNames={})
     
    yAxis:[
        ## Serie add
              
        #foreach ($yAxis in $axisList)   
                
        	#if ($yAxis.position != "bottom")
        	{            	        	
        		#if ($yAxis.min && $yAxis.min!="")	
					min: $yAxis.min,
    			#elseif ($yAxis.min && $yAxis.min=="")
    				min: 0,
    			#end
    			
		        #if ($yAxis.max && $yAxis.max!="")   
					max: $yAxis.max,	
    			#elseif ($yAxis.max && $yAxis.max=="")
    				max: 0,
    			#end
		        
		        #set($counterYAxisNames["$yAxis.alias"] = $counterYAxis)
		        
	        	title: {
		        	#if($yAxis.TITLE.enabled)
				 	 	enabled: $yAxis.TITLE.enabled
				 	#end
			 	 	
			 	 	#if($yAxis.TITLE.text)
	        			text: '$yAxis.TITLE.text',
	        		#end
	        		
				 	#if( $yAxis.TITLE.style )
		        		style:{
		        		
				        	#foreach($styleName in $yAxis.TITLE.style.keySet())
				        	
				        		#set ($axisTitleStyle = $yAxis.TITLE.style[$styleName])
				        		
				        		#if ($styleName == 'fontWeight' && ($axisTitleStyle == 'italic' || $axisTitleStyle == 'normal'))
				        			fontStyle: '$axisTitleStyle',
								#elseif($styleName == 'fontWeight' && $axisTitleStyle == 'underline')
				        			textDecoration: 'underline',
				        		#elseif($styleName == 'align')
				        			#set($alignTitle = $axisTitleStyle)
								#else		        			
				        			$styleName: '$axisTitleStyle',
				        		#end
				        		
				        	#end			        	
		        		},
		        		
		        		#*
			        		Mapping between alignment types provided by the alignment combo of the Y-axis Title
			        		and the alignment types provided for this item by the Highcharts library
			        		
			        		@author: danristo (danilo.ristovski@mht.net)
			        	*#				        	
			        	#if($alignTitle!="" && $alignTitle!="null")			        	
			        		#if($alignTitle == "left")
			        			align: "high",
			        		#elseif($alignTitle == "right")
			        			align: "low",
			        		#else
			        			align: "middle",
			        		#end				        		
			        	#end
		        	#end
	        	},
	        	
	        	#if($yAxis.lineColor && $yAxis.lineColor!="")
	        		lineColor: '$yAxis.lineColor', ##'#339',
	            #end
	            
	        	#if($yAxis.tickPosition && $yAxis.tickPosition!="")
	        		tickPosition: '$yAxis.tickPosition',
	        	#end
	        	
	            #if($yAxis.tickColor && $yAxis.tickColor!="")
	            	tickColor: '$yAxis.tickColor',
	            #end
	            
	            #if($yAxis.minorTickColor  && $yAxis.minorTickColor!="")
	            	minorTickColor: '$yAxis.minorTickColor',
	            #end
	            	        	
	         	#*#if ($yAxis.offset && $yAxis.offset!="")    	
					offset: $yAxis.offset,    			   				
    			#end*#
    			
    			#set($offsetValue = $counterYAxis*(-30))
    			
    			offset: $offsetValue, 
    			
    			 #if ($yAxis.lineWidth && $yAxis.lineWidth!="")  
    					lineWidth: $yAxis.lineWidth, 				
    			#end
    			
    			 #if ($yAxis.minorTickLength && $yAxis.minorTickLength!="") 
    					minorTickLength: $yAxis.minorTickLength,				
    			#end
    			
    			 #if ($yAxis.minorTickWidth && $yAxis.minorTickWidth!="")
    					minorTickWidth: $yAxis.minorTickWidth,    				
    			#end
    			
    			 #if ($yAxis.tickWidth && $yAxis.tickWidth!="")
    					tickWidth: $yAxis.tickWidth,
    			#end
	            
			 	#if ($yAxis.tickLength && $yAxis.tickLength!="")
    					tickLength: $yAxis.tickLength,
    			#end
	        	
	            #if($yAxis.endOnTickGauge)
	            	endOnTick: $yAxis.endOnTickGauge,
	            #end
	            
	        	#if($yAxis.minorTickInterval == '')
	        		minorTickInterval: 'auto',
        		#else
        			minorTickInterval: $yAxis.minorTickInterval,
	        	#end
	            
	            #if($yAxis.minorTickPosition)
	            	minorTickPosition: '$yAxis.minorTickPosition',
	            #end
				
				#if($yAxis.tickPixelInterval && $yAxis.tickPixelInterval!="")
	            	tickPixelInterval: $yAxis.tickPixelInterval,
	            #end
	        	
	        	#if($yAxis.LABELS)
	        	labels: {
	        		
	        			#if ($yAxis.LABELS.distance && $yAxis.LABELS.distance!="")
	    						distance: $yAxis.LABELS.distance,
    					#end 
    			
	    			 	#if ($yAxis.LABELS.rotation && $yAxis.LABELS.rotation!="")    	
	    						rotation: $yAxis.LABELS.rotation,
    					#end
	                
		    		#if($yAxis.style)
		        		style:{
			        	#foreach($styleName in $yAxis.style.keySet())			        	
			        		#set ($axisStyle = $yAxis.style[$styleName])
			        					        		
			        		#if ($styleName == 'fontWeight' && ($axisStyle == 'italic' || $axisStyle == 'normal'))
			        			fontStyle: '$axisStyle',
							#elseif($styleName == 'fontWeight' && $axisStyle == 'underline')
			        			textDecoration: 'underline',			        					        		
							#elseif($styleName == 'align')
			        			#set($alignLabels = $axisStyle)
							#else
			        			$styleName: '$axisStyle',
			        		#end
			        	#end
		        		},
		        		
		        		#*			        				        		
			        		Alignment for Y-axis labels.
			        		
			        		@author: danristo (danilo.ristovski@mht.net)
			        	*#				        	
			        	#if($alignLabels!="" && $alignLabels!="null")	
			        		align: "$alignLabels"		        					        				        		
			        	#end
		        		
		        	#end
	            },
	        	#end
	        	
	        	#if($yAxis.PLOTBANDS)
		        	plotBands: [        	
		        	
		        	#set($plots = $yAxis.PLOTBANDS.PLOT) 
		        	       	
		        	#if ($plots.class.name == "java.util.ArrayList")
		        	
			        	#foreach($plotElement in $plots)
		        		{
			        		#foreach($valueKey in $plotElement.keySet())
				        	
				    			#if ($valueKey == "color" && $plotElement.color)
				    				color: '$plotElement.color',
				    			#elseif ($valueKey == "from")
				    				from: $plotElement.from,
				    			#elseif ($valueKey == "to")
				    				to: $plotElement.to,
				    			#end
		        			
		        			#end
		        		},
			        	#end
			        	
			        #else
			         
			         	#if ($plots.color != "" && $plots.from != "" && $plots.to != "")
				        	{
				        		#if($plots.color != "")
				        			color: '$plots.color',
				        		#end
				        		
				        		#if($plots.from != "")
				        			from: $plots.from,
				        		#end
				        		
				        		#if($plots.to != "")
				        			to: $plots.to
				        		#end		        		
				        	},
				        #end
			        	
			        #end
		        	
		        	#*
		        	#foreach($valueKey in $yAxis.PLOTBANDS.PLOT.keySet())
		        	{
		    			#if ($valueKey == "color")
		    				color: $yAxis.PLOTBANDS.PLOT.color
		    			#end
	        			
        			},
	        		#end
		        	
		        	#if ($yAxis.PLOTBANDS.PLOT.class.name != "java.util.LinkedHashMap")
		        	
			        	#foreach($band in $yAxis.PLOTBANDS.PLOT)
			        	{
			        	
			        		from: $band.from,
			        		to: $band.to,
			        		color: '$band.color'
			        		
			        	},
			        	#end 
		        	#else
		        		{
		        			#if ($yAxis.PLOTBANDS.PLOT.from != '')
			        			from: $yAxis.PLOTBANDS.PLOT.from,
		        			#else
		        				from: '',
		        			#end
		        			
		        			#if ($yAxis.PLOTBANDS.PLOT.to != '')
			        			to: $yAxis.PLOTBANDS.PLOT.to,
		        			#else
		        				to: '',
		        			#end
		        			
		        			#if ($yAxis.PLOTBANDS.PLOT.color != '')
			        			color: $yAxis.PLOTBANDS.PLOT.color,
		        			#else
		        				color: '',
		        			#end
			        	}
		        	#end
		        	*#
		        	]
		        #end
		        },
    		#end       
    		
    		#set($counterYAxis = $counterYAxis+1)      
        #end
        ## END Serie add
        ],

    
    series: [
    
    	#set($counterYAxis = 0)
    	
    	#foreach($valueKey in $seriesMap.keySet())
    	
	    	#set($relatedSerie = $seriesMap.get($valueKey))
	    	{
	    	name: '$relatedSerie.name',
	    	
	    	#if($relatedSerie.color)
	    		color: '$relatedSerie.color',
	    	#end
	    	
	    	#*
	    		This parameters links serie (data) and it's dials with the
	    		appropriate Y-axis on the GAUGE chart.
	    		
	    		@author: danristo (danilo.ristovski@mht.net)
	    	*#
	    	yAxis: $counterYAxisNames.get($relatedSerie.axis),
	    	
	    	#set($counterYAxis = $counterYAxis + 1)	    	
	    		    	
	        data: [
	    	    #set($relatedSerieColName = "$relatedSerie.column"+"_#if($relatedSerie.groupingFunction)$relatedSerie.groupingFunction#{else}SUM#end")
	    	    #set($serieColumnsMapped = $dataColumnsMapper.get($relatedSerieColName)) ## "Vendite_AVG" -> "column_5" ## "Ricavi_SUM" -> "column_6"
				
				#foreach($row in $rows)
					#set ($serieValue = $row.get($serieColumnsMapped))
					$serieValue,
				#end
	    	],
	    	
	    	#*
	    		Data labels for the gauge. For gauges, the data labels are enabled by default 
	    		and shown in a bordered box below the point.
	    		(from the Highcharts API)
	    		
	    		@commentBy Danilo Ristovski (danristo, danilo.ristovski@mht.net)
	    	*#
	    	dataLabels: {
	    	
		    	#* 
		    		Added second part of the if-statement ($relatedSerie.DATA_LABELS.yPositionDataLabels!="") since 
		    		we can skip specification of the y-position data label for some serie items. If not specified
		    		like this (skipping data definition for property that are not mandatory), error on browser
		    		appears since it is not possible to decode JSON out of the JSON string from the response (chart.jsp).
		    		
		    		@editedBy Danilo Ristovski (danristo, danilo.ristovski@mht.net)
		    	*#
		    	#if($relatedSerie.DATA_LABELS.yPositionDataLabels && $relatedSerie.DATA_LABELS.yPositionDataLabels!="")
		    		y: $relatedSerie.DATA_LABELS.yPositionDataLabels,
		    	#end
		    	
		    	#if($relatedSerie.DATA_LABELS.colorDataLabels)
		    		color: '$relatedSerie.DATA_LABELS.colorDataLabels',
		    	#end
		    	
	    	 	#*
		    		======================================================================
		    		======================================================================
		    		START: Part of the code that handles whether the data lebels are going to
		    		be presented via the format or via the prefix+precision+postfix.
		    		
		    		@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)
		    		======================================================================
		    		======================================================================
		    	*#

		    	#set($formatDataLabels = '')
		    	
		    	#*
		    		If the "Show value" option is checked for the particular serie item
		    		the format or prefix+precision+postfix will be shown. The decision
		    		which of those two aspects will be taken is going to be made based
		    		on the value of the "serieFormatOrPrecision" parameter.
		    	*#
		    	#set($relatedSerieShowValue = $relatedSerie.showValue)
		    	#set($relatedSerieFormatOrPrecision = $relatedSerie.serieFormatOrPrecision)				
	
				#if ($relatedSerieShowValue != '')
	                
	                enabled: $relatedSerieShowValue,
	               
	                #*
	                	If the user took the format as the criteria of displaying the
	                	serie value in the belonging data label, take the format that
	                	is specified and simply display value as formatted.
	                	
	                	@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)                	
	                *#
	                #if ($relatedSerieFormatOrPrecision.toLowerCase() == "format")
	                	
	                	#*
	                		If the format string is empty we will take the default 
	                		string that Highcharts API prescribes: '{y}'. 
	                	*#
	                	#if ($relatedSerie.serieFormat == '')
	                		format: '{y}',
	                	#else				                	
			    			format: '$relatedSerie.serieFormat',
		    			#end
			    		
			    	#elseif ($relatedSerieFormatOrPrecision.toLowerCase() == "precision")
			    		
			    		#set ($postfixValueAsString = '')
			    		
			    		#set($emptyPrecision = false)
			    		
			    		#if ($relatedSerie.precision != '')
			    		#end
			    		
		                #if ($relatedSerie.postfixChar != '')
		                    #set ($postfixValueAsString = ' ' + $relatedSerie.postfixChar)
						#end
		                
		                #set ($prefixValueAsString = '')
		                
		                #if ($relatedSerie.prefixChar != '')
		                    #set ($prefixValueAsString = $relatedSerie.prefixChar + ' ')
						#end
		                
		                #set ($precisionValueAsString = '')
		                
		                #*
		                	This is the template for the precision: "{y:,.(x)f}".
		                	
		                	'y:': 		The value of related serie that is going to be presented
		                	',': 		The comma is used for separating thousands in 'y' numeric value.
		                	'.(x)f': 	The precision is used from the configuration user specified.
		                *#
		                #if ($relatedSerie.precision != '')
		                    #set ($precisionValueAsString = ':,.' + $relatedSerie.precision + 'f')
						#end
		                
		                #set ($formatDataLabels = ${prefixValueAsString} + '{y' + $precisionValueAsString + '}' + ${postfixValueAsString})
		                
		                format: '$formatDataLabels',
			    		
			    	#end
	                
				#end    	
		    		  
		    	#*
		    		Commented by Danilo Ristovski
		    		
		    		Take the format of the serie item for their data label
		    	*#  	
		    	#*
			    	#if($relatedSerie.DATA_LABELS.formatDataLabels && $relatedSerie.DATA_LABELS.formatDataLabels != '')
			    		format: '$relatedSerie.DATA_LABELS.formatDataLabels',
			    	#else
			    		format: '$formatDataLabels',
			    	#end
		    	*#	    	
		    	
		    	#*
		    		======================================================================
		    		======================================================================
		    		END: Part of the code that handles whether the data lebels are going to
		    		be presented via the format or via the prefix+precision+postfix.
		    		
		    		Danilo Ristovski
		    		======================================================================
		    		======================================================================
		    	*#
	    	},
	    	
        	tooltip: { 
        	
        		serieFormatOrPrecision: '$relatedSerieFormatOrPrecision.toLowerCase()',
        	
        	 	#if ($relatedSerieFormatOrPrecision.toLowerCase() == "format")
                
		    		format: '$relatedSerie.serieFormat',
		    		
		    	#elseif ($relatedSerieFormatOrPrecision.toLowerCase() == "precision")
		    	
					#set($seriePrefix = $relatedSerie.prefixChar)
					#if($seriePrefix)
						valuePrefix: '$seriePrefix',
					#end
						
					#set($seriePostfix = $relatedSerie.postfixChar)
					#if($seriePostfix)
						valueSuffix: '$seriePostfix',
					#end				
						
					#if ($relatedSerie.precision)
						valueDecimals: '$relatedSerie.precision',
					#end
					
				#end
				
				#if ($relatedSerie.TOOLTIP.style.fontWeight != '')
					ttFontWeight: '$relatedSerie.TOOLTIP.style.fontWeight',
				#end	
				
				#*
					If background color for the serie tooltip is not defined (empty)
					take the default value (#FCFFC5) so the tooltip can be readable 
					over the chart that stays behind it. Otherwise, take the value 
					of the background color specified by the user.				
					@author: danristo (danilo.ristovski@mht.net)
				*#
				#if ($relatedSerie.TOOLTIP.backgroundColor!="")
                	ttBackColor: '$relatedSerie.TOOLTIP.backgroundColor',
	            #else
	            	ttBackColor: '#FCFFC5',	
				#end
				
				#if ($relatedSerie.TOOLTIP.style.color != '')
					ttColor: '$relatedSerie.TOOLTIP.style.color' ,
				#end
					
				#if ($relatedSerie.TOOLTIP.style.align != '')
					ttAlign: '$relatedSerie.TOOLTIP.style.align' ,
				#end
					
				#if ($relatedSerie.TOOLTIP.style.fontFamily && $relatedSerie.TOOLTIP.style.fontFamily != '')
					ttFont: '$relatedSerie.TOOLTIP.style.fontFamily' ,	
				#end
					
				#if ($relatedSerie.TOOLTIP.style.fontWeight != '')
					ttFontWeight: '$relatedSerie.TOOLTIP.style.fontWeight',
				#end
					
				#if ($relatedSerie.TOOLTIP.style.fontSize != '')
					ttFontSize: '$relatedSerie.TOOLTIP.style.fontSize' ,
				#end		
			},		
						
			#if ($relatedSerie.DIAL.backgroundColorDial)
				
				#*
					Determining what should length of dial(s) be. This is important since
					it is crucial that dial 
				*#
				#set($percentDialAxis = (100-$counterYAxisNames.get($relatedSerie.axis)*9)+"%")
				
				dial: 
				{
	                backgroundColor: '$relatedSerie.DIAL.backgroundColorDial',
	                
	                ## This one manages the length of the dial
	                radius: "$percentDialAxis",
	            },
	            
            #end              
        },
	    #end
	],
    
    tooltip: {
        useHTML: true,
        backgroundColor: null,
        borderWidth: 2,
        style: {
            padding: 0
        },
        formatter: function() {		
       
        	var ttColor = this.series.tooltipOptions.ttColor ? this.series.tooltipOptions.ttColor : "";
        	var ttBackColor = this.series.tooltipOptions.ttBackColor ? this.series.tooltipOptions.ttBackColor : "";
        	
        	var ttAlign = this.series.tooltipOptions.ttAlign ? this.series.tooltipOptions.ttAlign : '';
        	var ttFont = this.series.tooltipOptions.ttFont ? ' ' + this.series.tooltipOptions.ttFont : '';
        	var ttFontSize = this.series.tooltipOptions.ttFontSize ? ' ' + this.series.tooltipOptions.ttFontSize : '';
        	var ttFontWeight = this.series.tooltipOptions.ttFontWeight ? ' ' + this.series.tooltipOptions.ttFontWeight : '';
        	            	       	
        	/*
        		======================================================
        		START: Part of the code that creates the template particular
        		serie item depending on the method used for structuring the
        		data that should be displayed in the tooltip (format or
        		precision).
					    		
	    		Danilo Ristovski
        		======================================================
        	*/
        	       	
        	/*
        		Depending on font style chosen by the user for the serie tooltip
        		we will specify respective CSS attribute so it can be taken by the
        		tooltip.
        		@author: danristo (danilo.ristovski@mht.net)
        	*/
        	var tooltipFontStyle = "";
        	
        	if (ttFontWeight == " underline")
        	{
        		tooltipFontStyle = " text-decoration: underline;";
        	}
        	else if (ttFontWeight == " italic")
        	{
        		tooltipFontStyle = "font-style: italic;";
        	}
        	else if (ttFontWeight == " bold")
        	{
        		tooltipFontStyle = "font-weight: bold;";
        	}
        	else
        	{
        		tooltipFontStyle = "font-weight: normal;";
        	}
        	
        	/*
        		Old implementation, with just precision option (and potentialy prefix and postfix).        		
        		@commentBy Danilo Ristovski (danristo, danilo.ristovski@mht.net)
        	*/
        	/*
	        	var valueDecimals = this.series.tooltipOptions.valueDecimals ? this.series.tooltipOptions.valueDecimals : -1;
	        	var valuePrefix = this.series.tooltipOptions.valuePrefix ? this.series.tooltipOptions.valuePrefix + ' ' : '';
	        	var valueSuffix = this.series.tooltipOptions.valueSuffix ? ' ' + this.series.tooltipOptions.valueSuffix : '';
	        	
	        	var thisValue = this.y;
	        	if(valueDecimals > -1 ) {
	        		var decimalPoint = Highcharts.getOptions().lang.decimalPoint,
	        			thousandsSep = Highcharts.getOptions().lang.thousandsSep;
	        			
	        		thisValue = Highcharts.numberFormat(thisValue, valueDecimals, decimalPoint, thousandsSep);
	        	}
	        	thisValue = valuePrefix + thisValue + valueSuffix;
	        */
	        
	        /*
        		The user is free to choose between two modalities for displaying the
        		serie value: 
        		
        			(1) precision potentially with its prefix and/or postfix: 
        					prefix + serie value with given number of decimals + postfix
        					
        			(2) format string (must follow the Highcharts format):
        					(a) prefix + {y:.(some not negative number)f} + postfix
        					(b) prefix + {point.y:.(some not negative number)f} + postfix
        					
        		@commentBy Danilo Ristovski (danristo, danilo.ristovski@mht.net)
        	*/        	
        	
        	/*
        		=============================
        		CASE: Precision is specified
        		=============================
        		If user specified precision for the serie value potentially with its
        		prefix and/or postfix, take those values in order to construct the 
        		string that will be displayed in the tooltip that appears when mouse
        		is over the particular serie. 
        		
        		@commentBy Danilo Ristovski (danristo, danilo.ristovski@mht.net)
        	*/
        	var valueDecimals = this.series.tooltipOptions.valueDecimals ? this.series.tooltipOptions.valueDecimals : -1;
        	var valuePrefix = this.series.tooltipOptions.valuePrefix ? this.series.tooltipOptions.valuePrefix + ' ' : '';
        	var valueSuffix = this.series.tooltipOptions.valueSuffix ? ' ' + this.series.tooltipOptions.valueSuffix : '';
        	
        	/*
        		=============================
        		CASE: Format is specified
        		=============================
        		If user specified format as modality of the displaying of the serie
        		value, take that string of the format and parse it in order to take
        		all constituents (prefix + separator for thousands + number of decimal 
        		points + postfix). All of those values are optional, but must be defined
        		in a proper way (with valid values) in order to display the tooltip
        		with expected results.
        		
        		@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)        		
        	*/
        	var format = this.series.tooltipOptions.format ? this.series.tooltipOptions.format : '';
        	
        	/*
        		The value of the serie that is hovered by the mouse.
        	*/
        	var thisValue = this.y;
        	
        	/*
        		Starting construction of the expression that is expected for the format
        		for the value of the serie. There are two possible constructions.
        		
        		@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)
        	*/
        	var onlyYString = "y";
        	var onlyPointYString = "point.y";
        	var yString = "y:";
        	var pointYString = "point.y:";
        	
        	/*
        		The starting and ending index of the expression of the format that is
        		first detected (if there is more than one expression) in the format string.
        		This is extracted for both possible constructions for the format separately. 
        		
        		@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)        		
        	*/
        	var yValueOnlyIndexStart = format.indexOf("{" + onlyYString);
        	var yValueOnlyIndexEnd = format.indexOf("}"); 
        	var pointYValueOnlyIndexStart = format.indexOf("{" + onlyPointYString);
        	var pointYValueOnlyIndexEnd = format.indexOf("}");       	
        	var yValueIndexStart = format.indexOf("{" + yString);
        	var yValueIndexEnd = format.indexOf("}");
        	var pointYValueIndexStart = format.indexOf("{" + pointYString);
        	var pointYValueIndexEnd = format.indexOf("}");
        	        	
        	var prefixText = "";
        	var postfixText = "";  
        	
        	var precision = -1;
        	var separatorOfThousands = "";
        	
        	var pointYValue = "";
        	var yValue = "";
        	
        	/*
        		Predefined decimal point and separator of thousands values in the
        		Highcharts library.
        		
        		@commentBy Danilo Ristovski (danristo, danilo.ristovski@mht.net)
        	*/
        	var decimalPoint = Highcharts.getOptions().lang.decimalPoint,
    			thousandsSep = Highcharts.getOptions().lang.thousandsSep;
        
        	/*
        		This is the way to inspect if there is more than one expression inside the
        		format string for the serie item.
        		
        		@author Danilo Ristovski (danristo, danilo.ristovski@mht.net) 
        	*/
        	//var numberOfDiffPointYFormats = (format.match(new RegExp("{"+pointYString, "g")) || []).length;
        	//var numberOfDiffYFormats = (format.match(new RegExp("{"+yString, "g")) || []).length;        
			//console.log(format.match(new RegExp("{point.y:.([0-9]|[0-2][0-9]$)f", "g")));
			/*
				If the starting part of the construction of the expression within the format 
				of the serie's tooltip is specified via the "point.y:".
				
				@author Danilo Ristovski (danristo, danilo.ristovski@mht.net) 
			*/
			if (pointYValueIndexStart >= 0)
        	{
        		/*
        			Take the whole expression within the format.
        		*/
        		pointYValue = format.substring(pointYValueIndexStart, pointYValueIndexEnd+1);
        		
        		/*
        			Take the pure content of the expression - the format itself.
        		*/
        		var formatPure = pointYValue.substring(pointYString.length+1,pointYValue.length-1); 
        		
        		/*
        			Extract the precision (number of decimal points) from this string.
        		*/
        		if(formatPure.indexOf(decimalPoint)>=0 && formatPure.indexOf("f")>=0)
        		{
        			precision = formatPure.substring(formatPure.indexOf(decimalPoint)+1,formatPure.indexOf("f"));
        		}
        		
        		/*
        			Inspect if there is thousands separator within the expression.
        		*/
        		if(formatPure.indexOf(thousandsSep)>=0)
        		{
        			separatorOfThousands = thousandsSep;
        		}
        		
        		/*
        			Extract the prefix text and the postfix text from the whole format string.
        		*/
        		prefixText = format.substring(0,pointYValueIndexStart);
        		postfixText = format.substring(pointYValueIndexEnd+1,format.length);
        	}
        	
        	/*
				If the starting part of the construction of the expression within the format 
				of the serie's tooltip is specified via the "y:".
				
				@author Danilo Ristovski (danristo, danilo.ristovski@mht.net) 
			*/
        	else if (yValueIndexStart >= 0)
        	{
        		yValue = format.substring(yValueIndexStart, yValueIndexEnd+1);
        		
        		var formatPure = yValue.substring(yString.length+1,yValue.length-1);     
        		
        		if(formatPure.indexOf(decimalPoint)>=0 && formatPure.indexOf("f")>=0)
        		{
        			precision = formatPure.substring(formatPure.indexOf(decimalPoint)+1,formatPure.indexOf("f"));
        		}
        		
        		if(formatPure.indexOf(thousandsSep)>=0)
        		{
        			separatorOfThousands = thousandsSep;
        		}
        		
        		prefixText = format.substring(0,yValueIndexStart);
        		postfixText = format.substring(yValueIndexEnd+1,format.length);
        	}
        	
        	else if (yValueOnlyIndexStart >= 0)
        	{
        		//yValue = format.substring(yValueOnlyIndexStart, yValueOnlyIndexEnd+1);
        		
        		/*var formatPure = yValue.substring(yString.length+1,yValue.length-1);     
        		
        		if(formatPure.indexOf(decimalPoint)>=0 && formatPure.indexOf("f")>=0)
        		{
        			precision = formatPure.substring(formatPure.indexOf(decimalPoint)+1,formatPure.indexOf("f"));
        		}
        		
        		if(formatPure.indexOf(thousandsSep)>=0)
        		{
        			separatorOfThousands = thousandsSep;
        		}*/
        		
        		prefixText = format.substring(0,yValueOnlyIndexStart);
        		postfixText = format.substring(yValueOnlyIndexEnd+1,format.length);
        	}
        	
        	else if (pointYValueOnlyIndexStart >= 0)
        	{
        		prefixText = format.substring(0,pointYValueOnlyIndexStart);
        		postfixText = format.substring(pointYValueOnlyIndexEnd+1,format.length);
        	}
        	/*
        		There is no expression for serie (y, y:, point.y)
        	*/
        	else
        	{
        		prefixText = format.substring(0,format.length);
        		postfixText = "";
        	}
        	
        	/*
        		Construct the final string for the serie tooltip depending on the user's 
        		choice on the modality of the display of the serie value in the tolltip - 
        		whether it is the format or precision (plus prefix/postfix). The if-part
        		is handling the case when precision is used.
        	*/
        	if (this.series.tooltipOptions.serieFormatOrPrecision.toLowerCase() == "precision")
        	{
	        	if(valueDecimals > -1 ) 
	        	{
	        		thisValue = Highcharts.numberFormat(thisValue, valueDecimals, decimalPoint, thousandsSep);
	        	}
	        	
	        	thisValue = valuePrefix + thisValue + valueSuffix;
        	}
        	else if (this.series.tooltipOptions.serieFormatOrPrecision.toLowerCase() == "format")
        	{    
    			/*
    				In those three cases we are dealing with the pure serie value (without any
    				kind of formatting, since this is the default behavior within the Highcharts
    				library.
    			*/
    			
    			if ( format != "" 
    					&& format != ("{" + onlyYString + "}") 
    							&& format != ("{" + onlyPointYString + "}") )
    			{
    				if (format.indexOf("{" + yString)>=0 || format.indexOf("{" + pointYString)>=0)
					{											
						if (precision >= 0)
		    			{				
		    				thisValue = Highcharts.numberFormat(thisValue, precision, decimalPoint, separatorOfThousands);    				
		    				thisValue = prefixText+thisValue+postfixText;
		    			}
		    			else
		    			{
		    				thisValue = prefixText + " " + postfixText;
		    			}
					}
    				else if (format.indexOf("{" + onlyYString + "}")>=0 || format.indexOf("{" + onlyPointYString + "}")>=0)
    				{
    					precision = 0;	// Highcharts default
    					thisValue = Highcharts.numberFormat(thisValue, precision, decimalPoint, separatorOfThousands);
	    				thisValue = prefixText+thisValue+postfixText;
    				}
    				else
    				{
    					thisValue = prefixText+postfixText;
    				}
    			}
        	}
        	
        	/*
        		======================================================
        		END: Part of the code that creates the template particular
        		serie item depending on the method used for structuring the
        		data that should be displayed in the tooltip (format or
        		precision).
					    		
	    		Danilo Ristovski
        		======================================================
        	*/
        	
        	/*
        		Separate font elements (family, size and weight (style)) so the tooltip
        		font characteristics can be separately (independently) specified by the user.
        		@modifiedBy: danristo (danilo.ristovski@mht.net)
        	*/
            var result = 
            	'<div style="padding:10px;color:' + ttColor + '; opacity: 0.9; background:' + ttBackColor + ';' + " font-family: " + ttFont + "; "
            					+ tooltipFontStyle + " font-size: " + ttFontSize + ';text-align:' + ttAlign + ';">'; 
            
            /*
        		Removed bold font style (weight) as default one for the serie value, since
        		style of the fonts on the tooltip will be the same for every single font
        		element on it. HTML tag <strong> is removed.
        		@modifiedBy: danristo (danilo.ristovski@mht.net)
        	*/
            result += this.series.name + ': ' + thisValue + '</div>';
            
            return result;
        }
    },
    
    
    #if($chart.EMPTYMESSAGE != '')
    lang: {
        noData: "$chart.EMPTYMESSAGE.text"
    },
    noData: {
    	style:{
    	#foreach($styleName in $chart.EMPTYMESSAGE.style.keySet())
    		$styleName: '$chart.EMPTYMESSAGE.style[$styleName]',
    	#end
		}
    },
    #end
    
    credits: { ##remove bottom credits text
    	enabled: false
    },
}