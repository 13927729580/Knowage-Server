#set($dataFields = $data.metaData.fields) ## columns of data table
#set($dataColumnsMapper = {})

#foreach ($dataField in $dataFields) ## conversion column name to internal column name
	#if($dataField.class.name == 'java.util.LinkedHashMap')
		#set($workAroundNoPrint = $dataColumnsMapper.put($dataField.header , $dataField.name))
	#end
#end

#set($rows = $data.rows) ## data in table rows


#set($categorieColumns = $chart.VALUES.CATEGORY) ## metadata related to categories
#set($categorieColumnsMapped = $dataColumnsMapper.get($categorieColumns.column)) ## "product" -> "column_3"
	
#set($enableDrilldown = false)
#if($categorieColumns.groupby != '' && $chart.isCockpitEngine == 'false')
	#set($enableDrilldown = true)
#end

#set($crossNavigation = '')
#set($crossNavigation = $chart.DRILL)

/*
 $ crossNavigation:
 $crossNavigation
*/

#set($series = $chart.VALUES.SERIE) ## metadata related to series

#set($seriesMap = {}) ## conversion series metadata to map object

#if($series.class.name == 'java.util.LinkedHashMap')
	#set($workAroundNoPrint = $seriesMap.put($series.name , $series))
#else
	#set($serieKeyFeed = 0)
	#foreach($serie in $series)
		#set($serieMapKey = $serie.column + '_' + $serieKeyFeed)
		#set($workAroundNoPrint = $seriesMap.put($serieMapKey , $serie))
		
		#set($serieKeyFeed = $serieKeyFeed + 1)
	#end
#end

{
	#set($drilldownEnabledFlag = false)
	#if($enableDrilldown || $crossNavigation != '')
		#set($drilldownEnabledFlag = true)
	#end
	meta: {
		drilldownEnabled: $drilldownEnabledFlag,
	},

    chart: {
    	#set($chartTypeToPrint = 'column')
    	#if($chartType == 'line' || $chartType == 'radar')
    		#set($chartTypeToPrint = 'line')
    	#end
    	
    	## I think this could be useful (danristo) !!!
    	#if ($chartType != 'radar')
    		marginRight: 110,
		#end
    
        type: '$chartTypeToPrint',
    	#if($chartType == 'radar')
    	polar: true,
    	#end
        backgroundColor: '$chart.style.backgroundColor', ##outer chart background
        
        #if($chart.orientation == 'horizontal' && $chartTypeToPrint != 'pie' && $chartTypeToPrint != 'radar')
        inverted: true,
        #end
        
        #if($chart.height != '')
        height: $chart.height,
        #end
        
        #if($chart.width != '')
    	width: $chart.width,
    	#end
        
        borderColor: '$chart.style.backgroundColor',
    	style:{
    		#foreach($styleName in $chart.style.keySet())
    			#set ($chartStyleValue = $chart.style[$styleName])
    			#if ($styleName == 'fontWeight' && ($chartStyleValue == 'italic' || $chartStyleValue == 'normal')) 
        			fontStyle: '$chartStyleValue',
				#elseif($styleName == 'fontWeight' && $chartStyleValue == 'underline')
        			textDecoration: 'underline',
				#else		        			
        			$styleName: '$chartStyleValue',
        		#end
    		#end
    	},
    	
    	#if($drilldownEnabledFlag)
	    	#if($crossNavigation != '')
		    events: {
				drilldown: handleCrossNavigationTo,
				drillup: handleCrossNavigationFrom
		    },
    	
	    	#elseif($enableDrilldown)
		    events: {
				drilldown: handleDrilldown,
				drillup: handleDrillup
		    },
		    #end
	    #end
    },
   
    colors: [
    	
    	## @modifiedBy: danristo (danilo.ristovski@mht.net)
    	
    	#if ($chart.type.toUpperCase() != 'RADAR')
			#foreach($color in $chart.COLORPALETTE.COLOR)
				'$color.value', 
			#end
		#else
			#*
	 			If user specified more than one color from the color palette
	 			on the Designer when creating the chart, then we have an array
	 			list of elements. Otherwise, we are dealing with a hashmap.
	 			
	 			In the first case, create an array of colors. In the second 
	 			case take the only color user specified and put it as the only
	 			element of the array that we are now creating.
	 			
	 			@modifiedBy: danristo (danilo.ristovski@mht.net)
	 		*#	
	 			
			#*#if ($chart.COLORPALETTE.COLOR.class.name == 'java.util.ArrayList')
				#foreach($color in $chart.COLORPALETTE.COLOR)
					'$color.get('value')',			
				#end			
			#else
				'$chart.COLORPALETTE.COLOR.value'
			#end	*#
			
			#*
				If user specifies at least 2 colors (class name of the structure that hold data
				about colors picked in the color palette of the Designer will in this case be
				LinkedList, instead of LinkedHashMap as in other case - just one element) go 
				into the if-statement. If there are no picked color or there is just one, go
				into the else-statement.
				@author: danristo (danilo.ristovski@mht.net)
			*#
	 		
	 		#if ($chart.COLORPALETTE.COLOR && $chart.COLORPALETTE.COLOR.class.name != 'java.util.LinkedHashMap') 
				
				#foreach($color in $chart.COLORPALETTE.COLOR)
					'$color.value', 
				#end	
						
			#else		
				
				#*
					If user does not specify any color inside the color palette the chart
					will take predefined value for the color (#000000) (else-case).	Otherwise, 
					we will take the single value specified in the palette (if-case).
					@author: danristo (danilo.ristovski@mht.net)
				*#
				
				#if ($chart.COLORPALETTE.COLOR)
					'$chart.COLORPALETTE.COLOR.value'
				#else
					'#518BC6'
				#end
				
			#end
		#end
    ],
    
    title: {
        text: '$chart.TITLE.text',
        
        #set ($titleAlign = $chart.TITLE.style.align)
        #if ($titleAlign != '' )
        
        	#if ($titleAlign == 'left')
        	x: 70,
        	#elseif ($titleAlign == 'right')
        	x: -70,
        	#end
        
        align: '$titleAlign',
        #end
        
        style:{
        #foreach($styleName in $chart.TITLE.style.keySet())
        	#set ($axisTitleStyle = $chart.TITLE.style[$styleName])
    		#if ($styleName == 'fontWeight' && ($axisTitleStyle == 'italic' || $axisTitleStyle == 'normal'))
    			fontStyle: '$axisTitleStyle',
			#elseif($styleName == 'fontWeight' && $axisTitleStyle == 'underline')
    			textDecoration: 'underline',
			#else		        			
    			$styleName: '$axisTitleStyle',
    		#end
		#end
	    }
    },
    
    #if($chart.SUBTITLE.text != '')
    subtitle: {
        text: '$chart.SUBTITLE.text',
        
        #set ($subtitleAlign = $chart.SUBTITLE.style.align)
        #if ($subtitleAlign != '' )
        
        	#if ($subtitleAlign == 'left')
        	x: 70,
        	#elseif ($subtitleAlign == 'right')
        	x: -70,
        	#end
        
        align: '$subtitleAlign',
        #end
        
        style:{
        #foreach($styleName in $chart.SUBTITLE.style.keySet())
        	#set ($axisSubtitleStyle = $chart.SUBTITLE.style[$styleName])
    		#if ($styleName == 'fontWeight' && ($axisSubtitleStyle == 'italic' || $axisSubtitleStyle == 'normal'))
    			fontStyle: '$axisSubtitleStyle',
			#elseif($styleName == 'fontWeight' && $axisSubtitleStyle == 'underline')
    			textDecoration: 'underline',
			#else		        			
    			$styleName: '$axisSubtitleStyle',
    		#end
		#end
		}
    },
    #end
    
    legend: {
	    #if ($chart.LEGEND.show != '' && $chart.LEGEND.show == 'false')
	    enabled: false,
	    #end
	    
        #if ($chart.LEGEND.layout != '' )
        layout: '$chart.LEGEND.layout',
        #end
        
        #if ($chart.LEGEND.position != '' )
        verticalAlign: '$chart.LEGEND.position',
        #end
        
        #if ($chart.LEGEND.position != '' )
        align: '$chart.LEGEND.style.align',
        #end
        
        #if ($chart.LEGEND.floating != '')
        floating: $chart.LEGEND.floating,
        #end
        
    	#if($chart.LEGEND.floating == 'true')
    	
	        #if($chart.LEGEND.x != '')
	        x: $chart.LEGEND.x,
		    #end
	        
	        #if($chart.LEGEND.y != '')
	        y: $chart.LEGEND.y,
	    	#end
    	
    	#end
        
        #if($chart.LEGEND.style.backgroundColor != '')
        backgroundColor: '$chart.LEGEND.style.backgroundColor',
	    #end
	    
        #if($chart.LEGEND.style.borderWidth != '')
        borderWidth: $chart.LEGEND.style.borderWidth,
	    #end
	    
        shadow: true,
        itemStyle: { 
        	color: '$chart.LEGEND.style.color', 
        	fontSize: '$chart.LEGEND.style.fontSize', 
        	#if ($chart.LEGEND.style.fontWeight == 'italic')
        	fontStyle: 'italic',
        	#elseif ($chart.LEGEND.style.fontWeight == 'underline')
        	textDecoration: 'underline',
        	#else
        	fontWeight: '$chart.LEGEND.style.fontWeight',
        	#end
        }
    },

    ## Axises selection
    #set($axisList = $chart.AXES_LIST.AXIS)

    #set($xAxisList = {}) ## X Axises list container
    #set($yAxisList = {}) ## Y Axises list container
    #set($xAxisPositions = {}) ## X Axises integer positions list, for series references
    #set($yAxisPositions = {}) ## Y Axises integer positions list, for series references
    #set($xAxisCounter = 0) 
    #set($yAxisCounter = 0) 
    
    #foreach($axis in $axisList)
	 	#if($axis.type == 'Category')
	 		#set($workAroundNoPrint = $xAxisList.put($axis.alias , $axis))
	 		#set($workAroundNoPrint = $xAxisPositions.put($axis.alias , $xAxisCounter))
	 		
	 		#set($xAxisCounter = $xAxisCounter + 1)
	 	#end
	 	
	 	#if($axis.type == 'Serie')
	 		#if(($chartType == 'radar' && $yAxisCounter < 1) || $chartType != 'radar')
		 		#set($workAroundNoPrint = $yAxisList.put($axis.alias , $axis))
		 		#set($workAroundNoPrint = $yAxisPositions.put($axis.alias , $yAxisCounter))
	 		
		 		#set($yAxisCounter = $yAxisCounter + 1)
	 		#end
	 	#end
	#end
	
    xAxis:
	 #foreach($xAxisKey in $xAxisList.keySet())
	 	#set ($xAxis = $xAxisList[$xAxisKey])
	 
	{
	 	title: {
			text: '$xAxis.TITLE.text',
			##y:-150,
			 
			#set ($xTitleAlign = $xAxis.TITLE.style.align)
			#if( $xTitleAlign != '' )
				#if ($xTitleAlign == 'center' )
				align: 'middle',
				#elseif ($xTitleAlign == 'left' )
				align: 'low',
				#elseif ($xTitleAlign == 'right' )
				align: 'high',
				#end
			#end
			 
			style:{
	        	#foreach($styleName in $xAxis.TITLE.style.keySet())
		        	#set ($axisTitleStyle = $xAxis.TITLE.style[$styleName])
		        	#if ($styleName == 'fontWeight' && ($axisTitleStyle == 'italic' || $axisTitleStyle == 'normal'))
	        			fontStyle: '$axisTitleStyle',
					#elseif($styleName == 'fontWeight' && $axisTitleStyle == 'underline')
	        			textDecoration: 'underline',
	        		#elseif($styleName == 'align')
		        			#set($labelAlign=$axisTitleStyle)
					#elseif($axisTitleStyle != '')
	        			$styleName: '$axisTitleStyle',
	        		#end
	        	#end
		    },
		},
		 
		labels:{
		#if( $xAxis.style != '' )
        	style:{
	        	#foreach($styleName in $xAxis.style.keySet())
	        		#set ($axisStyle = $xAxis.style[$styleName])
	        		#if ($styleName == 'fontWeight' && ($axisStyle == 'italic' || $axisStyle == 'normal'))
	        			fontStyle: '$axisStyle',
					#elseif($styleName == 'fontWeight' && $axisStyle == 'underline')
	        			textDecoration: 'underline',
					#elseif($styleName == 'align')
	        			#set($labelAlign=$axisStyle)
	        		#elseif($styleName == 'rotate')
	        			#set($rotation=$axisStyle)		        			
					#else		        			
	        			$styleName: '$axisStyle',
	        		#end
	        	#end
        		},
        		
        		#*
        			If chart's orientation is horizontal, then skip axis label alignment (it will be 
        			predefined one - defined by the Highcharts library), since the label aligned left will 
        			overlap with the title (characteristic of this library). Hence, the value inside 
        			of the combo for alignment of labels on the axis inside of the X-axis panel's Axis 
        			style configuration popup will not be taken into account.
        			
        			@author: danristo (danilo.ristovski@mht.net)
        		*#  
        		#if($labelAlign && ($chart.orientation == 'vertical' || $chartType == "radar"))
        			align: "$labelAlign",
        		#end
        		
        		#if($rotation!="" &&  $rotation!="null")
        			rotation: $rotation,
    			#end
        	#end
		},

		#if($xAxis.position == 'top')
		 	opposite: true,
		#end
		 
		type: 'category',
	},
	#end
    
    
    yAxis: [
        ## Serie add
        #foreach($yAxisKey in $yAxisList.keySet())
        	#set ($yAxis = $yAxisList[$yAxisKey] )
        
        {
        	min: 0,
        	
        	title: {
        		text: '$yAxis.TITLE.text',
        		##x:50,
        		#*
        		#if( $yAxis.style.rotate != '' ) 
        			rotation: $yAxis.style.rotate,
        		#end
        		*#
        		
        		#if( $chartType != "radar" && $yAxis.TITLE.style.align != '' )
        			#if ($yAxis.TITLE.style.align == 'center' )
					align: 'middle',
					#else
					align: '$yAxis.TITLE.style.align',
					#end
				#end
			 
        		style:{
		        	#foreach($styleName in $yAxis.TITLE.style.keySet())
		        		#set ($axisTitleStyle = $yAxis.TITLE.style[$styleName])
		        		#if ($styleName == 'fontWeight' && ($axisTitleStyle == 'italic' || $axisTitleStyle == 'normal'))
		        			fontStyle: '$axisTitleStyle',
						#elseif($styleName == 'fontWeight' && $axisTitleStyle == 'underline')
		        			textDecoration: 'underline',
		        		#elseif($styleName == 'align')
		        			#set($labelAlign=$axisTitleStyle)
						#else		        			
		        			$styleName: '$axisTitleStyle',
		        		#end
		        	#end
        		},
        		
        		#if ($chartType == "radar")
	    			#if($labelAlign=="center" || $labelAlign=="")
	    				align: "middle",
	    			#elseif($labelAlign=="left")
	    				align: "low",
	    			#elseif($labelAlign=="right")
	    				align: "high",
	    			#end   
    			#end   
        	},
        	
        	labels: {
        		
        		x:0,
        	
	    		#if( $yAxis.style != '' ) 
	        		style:{
		        	#foreach($styleName in $yAxis.style.keySet())
		        		#set ($axisStyle = $yAxis.style[$styleName])
		        		#if ($styleName == 'fontWeight' && ($axisStyle == 'italic' || $axisStyle == 'normal'))
		        			fontStyle: '$axisStyle',
						#elseif($styleName == 'fontWeight' && $axisStyle == 'underline')
		        			textDecoration: 'underline',
		        		#elseif($styleName == 'align')
		        			#set($labelAlign=$axisStyle)
		        		#elseif($styleName == 'rotate')
		        			#set($rotation=$axisStyle)
						#else		        			
		        			$styleName: '$axisStyle',
		        		#end
		        	#end
	        		},
	        		
	        		#*
	        			If chart's orientation is vertical, then skip axis label alignment (it will be 
	        			predefined one - defined by the Highcharts library), since the label aligned left 
	        			will overlap with the title (characteristic of this library). Hence, the value inside 
	        			of the combo for alignment of labels on the axis inside of the Y-axis panel's Axis 
	        			style configuration popup will not be taken into account.
	        			
	        			@author: danristo (danilo.ristovski@mht.net)
	        		*# 	        		       		
	        		#if($labelAlign && ($chart.orientation == 'horizontal' || $chartType == "radar"))
	        			align: "$labelAlign",	        		     			
	        		#end
	        		        		
	        		#if($rotation!="" &&  $rotation!="null")
	        			rotation: $rotation,
	    			#end
	    			
	        	#end     		
            },
        	
	        #if($yAxis.MAJORGRID.interval != '')
        	tickInterval: $yAxis.MAJORGRID.interval,
		    #end
		    
	        #if($yAxis.MAJORGRID.style.color != '')
        	gridLineColor: '$yAxis.MAJORGRID.style.color',
		    #end
        	
        	#set($typeline = $yAxis.MAJORGRID.style.typeline)
        	#if($yAxis.MAJORGRID.style.typeline != '')
	        	#if($typeline == 'dashed')
	        		#set($convertedTypeline = 'Dash')
	        	#elseif($typeline == 'dotted')
	        		#set($convertedTypeline = 'Dot')
	    		#elseif($typeline == 'solid')
	        		#set($convertedTypeline = 'Solid')
				#else
	        		#set($convertedTypeline = $typeline)
	        	#end
	        	gridLineDashStyle: '$convertedTypeline',
        	#end
        	
	        #if($yAxis.MINORGRID.interval != '')
        	minorTickInterval: $yAxis.MINORGRID.interval,
		    #end
		    
	        #if($yAxis.MINORGRID.style.color != '')
        	minorGridLineColor: '$yAxis.MINORGRID.style.color',
		    #end
        	
        	#set($typeline = $yAxis.MINORGRID.style.typeline)
        	#if($typeline == 'dashed')
        		#set($convertedMinorTpeline = 'Dash')
    		#elseif($typeline == 'dotted')
        		#set($convertedMinorTpeline = 'Dot')
    		#elseif($typeline == 'solid')
        		#set($convertedMinorTpeline = 'Solid')
        	#end
        	minorGridLineDashStyle: '$convertedMinorTpeline',
        	
        	#if($yAxis.position == 'right')
        	opposite: true,
        	#end
        	
        	stackLabels: {
        		enabled: true
        	},
        },
        #end
        ## FINE Serie add
            
    ],
    
	series: [
	#foreach($valueKey in $seriesMap.keySet())
	    #set($relatedSerie = $seriesMap.get($valueKey))
	    	
	    {	
		#set($relatedSerieColor = false)
		#set($relatedSerieColor = $relatedSerie.color)
		#if($relatedSerieColor && $relatedSerieColor != '')
			color: '$relatedSerieColor',
	    #end
		
			name: '$relatedSerie.name',
		
		#set($relatedSerieType = '')
		#if($relatedSerie.type)
			#set($relatedSerieType = $relatedSerie.type)
		#end
		#if($relatedSerieType != '')		
			#if($relatedSerieType == 'bar')
				#set($relatedSerieType = 'column')
			#end		
			#if($relatedSerieType == 'radar')
				#set($relatedSerieType = 'line')
			#end		
	    	type: '$relatedSerieType',
	    #end
	    
	    	## makes the datalabels overlapping
	    	dataLabels: {
	    		allowOverlap: true
	    	},
	    	
	    	data: [
	    		#set($relatedSerieColName = "$relatedSerie.column"+"_#if($relatedSerie.groupingFunction)$relatedSerie.groupingFunction#{else}SUM#end")
	    	    #set($serieColumnsMapped = $dataColumnsMapper.get($relatedSerieColName)) ## "Vendite_AVG" -> "column_5" ## "Ricavi_SUM" -> "column_6"
				#foreach($row in $rows)
					#set ($serieValue = $row.get($serieColumnsMapped))
					#set ($serieCategoryName =  $row.get($categorieColumnsMapped))
					{
						##drilldown: $enableDrilldown,
						drilldown: $drilldownEnabledFlag,
						y: $serieValue,
						name: '$serieCategoryName',
						
						#if($crossNavigation != '') 
						crossNavigationDocumentName: '$crossNavigation.document',
						crossNavigationDocumentParams: [
							## if single PARAM node, not array
							#if($crossNavigation.PARAM_LIST.PARAM.class.name == "java.util.LinkedHashMap")
								#set($param = $crossNavigation.PARAM_LIST.PARAM)
								{ name: '$param.name', urlName:'$param.parameterUrlName', type: '$param.type', value: '$param.value' }
							#else
								##Array of parameters
								
								#foreach($param in $crossNavigation.PARAM_LIST.PARAM)
								{ name: '$param.name', urlName:'$param.parameterUrlName', type: '$param.type', value: '$param.value' },
								#end
							#end
						],
						#end
						
						#set($relatedSerieShowValue = $relatedSerie.showValue)
						#if ($relatedSerieShowValue != '')
						dataLabels: {
		                    enabled: $relatedSerieShowValue,
		                    
		                    #set ($postfixValueAsString = '')
		                    #if ($relatedSerie.postfixChar != '')
			                    #set ($postfixValueAsString = ' ' + $relatedSerie.postfixChar)
							#end
		                    
		                    #set ($prefixValueAsString = '')
		                    #if ($relatedSerie.prefixChar != '')
			                    #set ($prefixValueAsString = $relatedSerie.prefixChar + ' ')
							#end
		                    
		                    #set ($precisionValueAsString = '')
		                    #if ($relatedSerie.precision != '')
			                    #set ($precisionValueAsString = ':.' + $relatedSerie.precision + 'f')
							#end
		                    
		                    format: '${prefixValueAsString}{y$precisionValueAsString}${postfixValueAsString}',
		                                				
		                    #*
		                    formatter: function() {
		                    	return '${prefixValueAsString}' + '{' + this.y + '$precisionValueAsString' + '}' + '${postfixValueAsString}';
		                    },
		                    *#
		                }
						#end
					},
				#end
	    	],
	    	
			tooltip: { 
			#set($seriePrefix = $relatedSerie.prefixChar)
			#if($seriePrefix != '')
				valuePrefix: '$seriePrefix',
			#end
				
			#set($seriePostfix = $relatedSerie.postfixChar)
			#if($seriePostfix != '')
				valueSuffix: '$seriePostfix',
			#end
				
			#if ($relatedSerie.precision != '')
				valueDecimals: $relatedSerie.precision ,
			#end
				
			#*
				If background color for the serie tooltip is not defined (empty)
				take the default value (#FCFFC5) so the tooltip can be readable 
				over the chart that stays behind it. Otherwise, take the value 
				of the background color specified by the user.				
				@author: danristo (danilo.ristovski@mht.net)
			*#
			#if ($relatedSerie.TOOLTIP.backgroundColor!="")
                ttBackColor: '$relatedSerie.TOOLTIP.backgroundColor',
            #else
            	ttBackColor: '#FCFFC5',	## default background color for the serie tooltip
			#end
				
			#if ($relatedSerie.TOOLTIP.style.color != '')
				ttColor: '$relatedSerie.TOOLTIP.style.color' ,
			#end
				
			#if ($relatedSerie.TOOLTIP.style.align != '')
				ttAlign: '$relatedSerie.TOOLTIP.style.align' ,
			#end
				
			#if ($relatedSerie.TOOLTIP.style.fontFamily && $relatedSerie.TOOLTIP.style.fontFamily != '')
				ttFont: '$relatedSerie.TOOLTIP.style.fontFamily' ,
			#end
				
			#if ($relatedSerie.TOOLTIP.style.fontWeight != '')
				ttFontWeight: '$relatedSerie.TOOLTIP.style.fontWeight' ,
			#end
				
			#if ($relatedSerie.TOOLTIP.style.fontSize != '')
				ttFontSize: '$relatedSerie.TOOLTIP.style.fontSize' ,
			#end
			},
		
		#if($chartType != 'radar') 	
    		#set($referencedAxis = $relatedSerie.axis)
    		yAxis: $yAxisPositions[$referencedAxis]
    	#end
	    }, 
	#end
    ],
    
    tooltip: {
        useHTML: true,
        backgroundColor: null,
        borderWidth: 2,
        style: {
            padding: 0
        },
        formatter: function() {
        	var ttColor = this.series.tooltipOptions.ttColor ? this.series.tooltipOptions.ttColor : '';
        	var ttBackColor = this.series.tooltipOptions.ttBackColor ? this.series.tooltipOptions.ttBackColor : '';
        	
        	var ttAlign = this.series.tooltipOptions.ttAlign ? this.series.tooltipOptions.ttAlign : '';
        	var ttFont = this.series.tooltipOptions.ttFont ? ' ' + this.series.tooltipOptions.ttFont : '';
        	var ttFontSize = this.series.tooltipOptions.ttFontSize ? ' ' + this.series.tooltipOptions.ttFontSize : '';
        	var ttFontWeight = this.series.tooltipOptions.ttFontWeight ? ' ' + this.series.tooltipOptions.ttFontWeight : '';
        	       	
        	#*
        		Depending on font style chosen by the user for the serie tooltip
        		we will specify respective CSS attribute so it can be taken by the
        		tooltip.
        		@author: danristo (danilo.ristovski@mht.net)
        	*#
        	var tooltipFontStyle = "";
        	
        	if (ttFontWeight == " underline")
        	{
        		tooltipFontStyle = " text-decoration: underline;";
        	}
        	else if (ttFontWeight == " italic")
        	{
        		tooltipFontStyle = "font-style: italic;";
        	}
        	else if (ttFontWeight == " bold")
        	{
        		tooltipFontStyle = "font-weight: bold;";
        	}
        	else
        	{
        		tooltipFontStyle = "font-weight: normal;";
        	}
        	
        	var valueDecimals = this.series.tooltipOptions.valueDecimals ? this.series.tooltipOptions.valueDecimals : -1;
        	var valuePrefix = this.series.tooltipOptions.valuePrefix ? this.series.tooltipOptions.valuePrefix + ' ' : '';
        	var valueSuffix = this.series.tooltipOptions.valueSuffix ? ' ' + this.series.tooltipOptions.valueSuffix : '';
        	
        	var thisValue = this.y;
        	if(valueDecimals > -1 ) {
        		var decimalPoint = Highcharts.getOptions().lang.decimalPoint,
        			thousandsSep = Highcharts.getOptions().lang.thousandsSep;
        			
        		thisValue = Highcharts.numberFormat(thisValue, valueDecimals, decimalPoint, thousandsSep);
        	}
        	thisValue = valuePrefix + thisValue + valueSuffix;
        	
        	#*
        		Separate font elements (family, size and weight (style)) so the tooltip
        		font characteristics can be separately (independently) specified by the user.
        		@modifiedBy: danristo (danilo.ristovski@mht.net)
        	*# 
            var result = 
            	'<div style="padding:10px;color:' + ttColor + '; opacity: 0.9; background:' + ttBackColor + ';' + " font-family: " + ttFont + "; "
            					+ tooltipFontStyle + " font-size: " + ttFontSize + ';text-align:' + ttAlign + ';">'; 
            
            #*
        		Removed bold font style (weight) as default one for the serie value, since
        		style of the fonts on the tooltip will be the same for every single font
        		element on it. HTML tag <strong> is removed.
        		@modifiedBy: danristo (danilo.ristovski@mht.net)
        	*# 	
            result += '<span>' + this.key + '</span><br/>' + this.series.name + ': ' + thisValue + '</div>';
            return result;
        }
    },
    
    #if($enableDrilldown)
    drilldown: {
        series: []
    },
    #end
    
    lang: {
        noData: '$chart.EMPTYMESSAGE.text'
    },
    noData: {
    	style:{
    	#foreach($styleName in $chart.EMPTYMESSAGE.style.keySet())
    		$styleName: '$chart.EMPTYMESSAGE.style[$styleName]',
    	#end
		}
    },
    
    credits: { ##remove bottom credits text
    	enabled: false
    },
    
    plotOptions: {
        line: {
	        marker: {
                symbol: 'circle',
                lineWidth: 2
            }
        },
        #if($chart.isCockpitEngine == 'true' && $chart.outcomingEventsEnabled == 'true')
        series: {
            cursor: 'pointer',
            point: {
                events: {
                    click: handleCockpitSelection
                }
            },
            
            #* 
            	From Highcharts API: When a series contains a data array that is longer than this, 
            	only one dimensional arrays of numbers, or two dimensional arrays with x and y values 
            	are allowed. Also, only the first point is tested, and the rest are assumed to be the 
            	same format. This saves expensive data checking and indexing in long series. Set it to 
            	0 disable. Defaults to 1000.
            	
            	URL: http://api.highcharts.com/highcharts#plotOptions.series.turboThreshold
            	
            	We will increase this value in order to display series that contain a data array bigger
            	than 1000 (default), because it is most likely that we will have this situation very 
            	often.
            	
            	@author: danristo (danilo.ristovski@mht.net)
            *#
            turboThreshold: 5000
        }
        #end
    }
}