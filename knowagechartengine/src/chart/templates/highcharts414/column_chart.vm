#set($dataFields = $data.metaData.fields) ## columns of data table
#set($dataColumnsMapper = {})

#foreach ($dataField in $dataFields) ## conversion column name to internal column name
	#if($dataField.class.name == 'java.util.LinkedHashMap')
		#set($workAroundNoPrint = $dataColumnsMapper.put($dataField.header , $dataField.name))
	#end
#end

#set($rows = $data.rows) ## data in table rows

#set($categorieColumns = $chart.VALUES.CATEGORY) ## metadata related to categories
#set($categorieColumnsMapped = $dataColumnsMapper.get($categorieColumns.column)) ## "product" -> "column_3"
	
#set($enableDrilldown = false)
#if($categorieColumns.groupby != '' && $chart.isCockpitEngine == 'false')
	#set($enableDrilldown = true)
#end

#set($crossNavigation = '')
#set($crossNavigation = $chart.DRILL)

#set($series = $chart.VALUES.SERIE) ## metadata related to series

#set($seriesMap = {}) ## conversion series metadata to map object

#if($series.class.name == 'java.util.LinkedHashMap')
	#set($workAroundNoPrint = $seriesMap.put($series.name , $series))
#else
	#set($serieKeyFeed = 0)
	#foreach($serie in $series)
		#set($serieMapKey = $serie.column + '_' + $serieKeyFeed)
		#set($workAroundNoPrint = $seriesMap.put($serieMapKey , $serie))
		
		#set($serieKeyFeed = $serieKeyFeed + 1)
	#end
#end

{
	#set($drilldownEnabledFlag = false)
	#if($enableDrilldown || $crossNavigation != '')
		#set($drilldownEnabledFlag = true)
	#end
	meta: {
		drilldownEnabled: $drilldownEnabledFlag,
	},

    chart: {
    	#set($chartTypeToPrint = 'column')
    	#if($chartType == 'line' || $chartType == 'radar')
    		#set($chartTypeToPrint = 'line')
    	#end
    	
    	#*
    		Commented on 19.12: KNOWAGE-327 ISSUE
    	
	    	## I think this could be useful (danristo) !!!
	    	#if ($chartType != 'radar')
	    		marginRight: 110,
			#end
		*#
    
        type: '$chartTypeToPrint',
    	#if($chartType == 'radar')
    	polar: true,
    	#end
        backgroundColor: '$chart.style.backgroundColor', ##outer chart background
        
        #if($chart.orientation == 'horizontal' && $chartTypeToPrint != 'pie' && $chartTypeToPrint != 'radar')
        inverted: true,
        #end
        
        #if($chart.height != '')
        height: $chart.height,
        #end
        
        #if($chart.width != '')
    	width: $chart.width,
    	#end
        
        borderColor: '$chart.style.backgroundColor',
    	style:{
    		#foreach($styleName in $chart.style.keySet())
    			#set ($chartStyleValue = $chart.style[$styleName])
    			#if ($styleName == 'fontWeight' && ($chartStyleValue == 'italic' || $chartStyleValue == 'normal')) 
        			fontStyle: '$chartStyleValue',
				#elseif($styleName == 'fontWeight' && $chartStyleValue == 'underline')
        			textDecoration: 'underline',
				#else		        			
        			$styleName: '$chartStyleValue',
        		#end
    		#end
    	},
    	
    	#*
    		If the web application that calls the VM is Highcharts Export
    		we should not provide this information (property 'events').
    		
    		@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)
    	*#
    	#if($drilldownEnabledFlag && $exportWebApp==false)
	    	#if($crossNavigation != '')
		    events: {
				drilldown: handleCrossNavigationTo,
				drillup: handleCrossNavigationFrom
		    },
    	
	    	#elseif($enableDrilldown)
		    events: {
				drilldown: handleDrilldown,
				drillup: handleDrillup
		    },
		    #end
	    #end
    },
   
    colors: [
    	
    	## @modifiedBy: danristo (danilo.ristovski@mht.net)
    	
    	#if ($chart.type.toUpperCase() != 'RADAR')
    		#if ($chart.COLORPALETTE.COLOR && $chart.COLORPALETTE.COLOR.class.name != 'java.util.LinkedHashMap') 
				
			#foreach($color in $chart.COLORPALETTE.COLOR)
				'$color.value', 
			#end
						
			#else		
				
				#if ($chart.COLORPALETTE.COLOR)
					'$chart.COLORPALETTE.COLOR.value'
				#else
					'#518BC6'
				#end
				
			#end
		#else
			#*
	 			If user specified more than one color from the color palette
	 			on the Designer when creating the chart, then we have an array
	 			list of elements. Otherwise, we are dealing with a hashmap.
	 			
	 			In the first case, create an array of colors. In the second 
	 			case take the only color user specified and put it as the only
	 			element of the array that we are now creating.
	 			
	 			@modifiedBy: danristo (danilo.ristovski@mht.net)
	 		*#	
	 			
			#*#if ($chart.COLORPALETTE.COLOR.class.name == 'java.util.ArrayList')
				#foreach($color in $chart.COLORPALETTE.COLOR)
					'$color.get('value')',			
				#end			
			#else
				'$chart.COLORPALETTE.COLOR.value'
			#end	*#
			
			#*
				If user specifies at least 2 colors (class name of the structure that hold data
				about colors picked in the color palette of the Designer will in this case be
				LinkedList, instead of LinkedHashMap as in other case - just one element) go 
				into the if-statement. If there are no picked color or there is just one, go
				into the else-statement.
				@author: danristo (danilo.ristovski@mht.net)
			*#
	 		
	 		#if ($chart.COLORPALETTE.COLOR && $chart.COLORPALETTE.COLOR.class.name != 'java.util.LinkedHashMap') 
				
				#foreach($color in $chart.COLORPALETTE.COLOR)
					'$color.value', 
				#end	
						
			#else		
				
				#*
					If user does not specify any color inside the color palette the chart
					will take predefined value for the color (#000000) (else-case).	Otherwise, 
					we will take the single value specified in the palette (if-case).
					@author: danristo (danilo.ristovski@mht.net)
				*#
				
				#if ($chart.COLORPALETTE.COLOR)
					'$chart.COLORPALETTE.COLOR.value'
				#else
					'#518BC6'
				#end
				
			#end
		#end
    ],
    
    title: {
        text: '$chart.TITLE.text',
        
        #set ($titleAlign = $chart.TITLE.style.align)
        #if ($titleAlign != '' )
        
        	#if ($titleAlign == 'left')
        	x: 70,
        	#elseif ($titleAlign == 'right')
        	x: -70,
        	#end
        
        align: '$titleAlign',
        #end
        
        style:{
        #foreach($styleName in $chart.TITLE.style.keySet())
        	#set ($axisTitleStyle = $chart.TITLE.style[$styleName])
    		#if ($styleName == 'fontWeight' && ($axisTitleStyle == 'italic' || $axisTitleStyle == 'normal'))
    			fontStyle: '$axisTitleStyle',
			#elseif($styleName == 'fontWeight' && $axisTitleStyle == 'underline')
    			textDecoration: 'underline',
			#else		        			
    			$styleName: '$axisTitleStyle',
    		#end
		#end
	    }
    },
    
    #if($chart.SUBTITLE.text != '')
    subtitle: {
        text: '$chart.SUBTITLE.text',
        
        #set ($subtitleAlign = $chart.SUBTITLE.style.align)
        #if ($subtitleAlign != '' )
        
        	#if ($subtitleAlign == 'left')
        	x: 70,
        	#elseif ($subtitleAlign == 'right')
        	x: -70,
        	#end
        
        align: '$subtitleAlign',
        #end
        
        style:{
        #foreach($styleName in $chart.SUBTITLE.style.keySet())
        	#set ($axisSubtitleStyle = $chart.SUBTITLE.style[$styleName])
    		#if ($styleName == 'fontWeight' && ($axisSubtitleStyle == 'italic' || $axisSubtitleStyle == 'normal'))
    			fontStyle: '$axisSubtitleStyle',
			#elseif($styleName == 'fontWeight' && $axisSubtitleStyle == 'underline')
    			textDecoration: 'underline',
			#else		        			
    			$styleName: '$axisSubtitleStyle',
    		#end
		#end
		}
    },
    #end
	 
	#if($chart.LEGEND.style.borderWidth != '')
    	#set($borderWidth = $chart.LEGEND.style.borderWidth)
    #end
	 
    #*
    	The logic for handling data needed for rendering of the chart.
    	
    	@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)
    *#
    #if ($chart.LEGEND.show != '' && ($chart.LEGEND.show == 'true' || $chart.LEGEND.show == true))
	     
	    #if ($chart.LEGEND.position == "")      
		 	
		 	legend: 
		 	{
		        enabled: true,
		        align: 'center', 
		        verticalAlign: 'bottom',
		        layout: 'horizontal',
		    
	    #end
	    
	    #if ($chart.LEGEND.position == "bottom")
	  
		    legend: 
		    {
	            enabled: true,
	            align: 'center',
	            verticalAlign: '$chart.LEGEND.position', 
	            layout: 'horizontal',
		    
	 	#end
	 	
	 	#if ($chart.LEGEND.position == "top")
	 	
	 		#*
		    	Take the size of the font that is used for the chart's title 
		    	and subtitle. We will use this for determining how much we
		    	should move the top legend downwards (towards the chart itself).
		    *#
		    #set($titleFontSize = $chart.TITLE.style.fontSize)
		    #set($subtitleFontSize = $chart.SUBTITLE.style.fontSize)
		    #set($titleText = $chart.TITLE.text)
		    #set($subtitleText = $chart.SUBTITLE.text)
		    
		    #set($totalDistanceLegend = 0)
		    
		    #if ($titleText != "")
		    
			    #*
					Take only numeric value from the font size parameter (that is 
					actually the string in this moment. 
					
					@author Danilo Ristovski (danristo, danilo.ristovski@mht.net) 
				*#
			    #if ($titleFontSize != "")
				    #foreach ($element in $titleFontSize.split("px"))  
				    	#set($titleFontSize = $element)
					#end				
				#else
					#set($titleFontSize = "15")
				#end
				
			#else 		
				
		    	#set($titleFontSize = "0")
		    					
			#end
			
			#if ($subtitleText != "")
		    
			    #*
					Take only numeric value from the font size parameter (that is 
					actually the string in this moment. 
					
					@author Danilo Ristovski (danristo, danilo.ristovski@mht.net) 
				*#
			    #if ($subtitleFontSize != "")
				    #foreach ($element in $subtitleFontSize.split("px"))  
				    	#set($subtitleFontSize = $element)
					#end				
				#else
					#set($subtitleFontSize = "15")
				#end
				
			#else 
				
				#set($subtitleFontSize = "0")
				
			#end
		   
		 	#*
				Convert chart's title and subtitle heights to Integer.
				
				@author Danilo Ristovski (danristo, danilo.ristovski@mht.net) 
			*#
		    #set($intTitleFontSize = 0)
		    #set($intSubtitleFontSize = 0)
		    #set($intBorderWidth = 0)
			#set($Integer1 = 0)
			#set($Integer2 = 0)
			#set($Integer3 = 0)
			#set($intTitleFontSize = $Integer1.parseInt($titleFontSize))		
			#set($intSubtitleFontSize = $Integer2.parseInt($subtitleFontSize))
			
			## If the parameter is NOT NULL
			#if ("$!borderWidth" != "")
				#set($intBorderWidth = $Integer3.parseInt($chart.LEGEND.style.borderWidth))
			#end
		
			#if ($titleText == "" && $subtitleText == "")
				#set($offsetFromTitleSubtitle = 0)
			#else
				#set($offsetFromTitleSubtitle = 15)
			#end		
		
			#*
				Append the offset to the total height of the chart's title and subtitle
				so it can have always the same distance from those two chart elements
				(no matter what is the size of title and subtitle).
				
				@author Danilo Ristovski (danristo, danilo.ristovski@mht.net) 
			*#
			#set($totalDistanceLegend  = ($intTitleFontSize + $intSubtitleFontSize + $intBorderWidth) + $offsetFromTitleSubtitle)
				 	
	 		legend: 
		    {
	          	enabled: true,
	            align: 'center',
	            verticalAlign: '$chart.LEGEND.position', 
	            layout: 'horizontal',
	          	y: $totalDistanceLegend,
		    
	 	#end
	        
	 	#if ($chart.LEGEND.position == "right" || $chart.LEGEND.position == "left")      
		 	
		 	legend: 
		 	{
		 		enabled: true,
		        align: '$chart.LEGEND.position', 
		        verticalAlign: 'middle',
		        layout: 'vertical',
		    
	    #end
	    		
	    		#if ($chart.LEGEND.floating != '')
		        	floating: $chart.LEGEND.floating,
		        #end
		        
		    	#if($chart.LEGEND.floating == 'true')
		    	
			        #if($chart.LEGEND.x != '')
			        	x: $chart.LEGEND.x,
				    #end
			        
			        #if($chart.LEGEND.y != '')
			        	y: $chart.LEGEND.y,
			    	#end
		    	
		    	#end
	    		
			    #if($chart.LEGEND.style.backgroundColor != '')
		        	backgroundColor: '$chart.LEGEND.style.backgroundColor',
			    #end
			    
		        #if($chart.LEGEND.style.borderWidth != '')
		        	borderWidth: $chart.LEGEND.style.borderWidth,
			    #end
			    
		        shadow: true,
		        
		        itemStyle: 
		        { 
		        	color: '$chart.LEGEND.style.color', 
		        	
		        	fontSize: '$chart.LEGEND.style.fontSize', 
		        	
		        	#if ($chart.LEGEND.style.fontFamily != '')
		        		fontFamily: '$chart.LEGEND.style.fontFamily',
		        	#end
		        	
		        	#if ($chart.LEGEND.style.fontWeight == 'italic')
		        		fontStyle: 'italic',
		        	#elseif ($chart.LEGEND.style.fontWeight == 'underline')
		        		textDecoration: 'underline',
		        	#else
		        		fontWeight: '$chart.LEGEND.style.fontWeight',
		        	#end
		        },
		        #if('$!chart.LEGEND.TITLE' != "" && '$chart.LEGEND.TITLE'!='')
		        title:
		        {   
		            #if('$chart.LEGEND.TITLE.text'!='')
		        	text:'$chart.LEGEND.TITLE.text',
		        	#end
		        	style:
		        	{	
		            #if ($chart.LEGEND.TITLE.style.color != '')
		        		color: '$chart.LEGEND.TITLE.style.color',
		            #end
		        	##if ($chart.LEGEND.TITLE.style.align != '')
		        	##	align: '$chart.LEGEND.TITLE.style.align',
		            ##end
		            #if ($chart.LEGEND.TITLE.style.fontSize != '')	
		        		fontSize: '$chart.LEGEND.TITLE.style.fontSize', 
		        	#end
		        	#if ($chart.LEGEND.TITLE.style.fontFamily != '')
		        		fontFamily: '$chart.LEGEND.TITLE.style.fontFamily',
		        	#end
		        	
		        	#if ($chart.LEGEND.TITLE.style.fontWeight == 'italic')
		        		fontStyle: 'italic',
		        	#elseif ($chart.LEGEND.TITLE.style.fontWeight == 'underline')
		        		textDecoration: 'underline',
		        	#else
		        		fontWeight: '$chart.LEGEND.TITLE.style.fontWeight',
		        	#end
		        	}	
		        }
		      #end  
		        
        	},
	    
	#else
		
		#* 
			If legend is disabled this JSON property ('enabled') should be false.
			
			@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)			
		*#
		legend:
		{
			enabled: false,
		},
	    
    #end
    
    #*
    legend: {
	    #if ($chart.LEGEND.show != '' && $chart.LEGEND.show == 'false')
	    enabled: false,
	    #end
	    
        #if ($chart.LEGEND.layout != '' )
        layout: '$chart.LEGEND.layout',
        #end
        
        #if ($chart.LEGEND.position != '' )
        verticalAlign: '$chart.LEGEND.position',
        #end
        
        #if ($chart.LEGEND.position != '' )
        align: '$chart.LEGEND.style.align',
        #end
        
        #if ($chart.LEGEND.floating != '')
        floating: $chart.LEGEND.floating,
        #end
        
    	#if($chart.LEGEND.floating == 'true')
    	
	        #if($chart.LEGEND.x != '')
	        x: $chart.LEGEND.x,
		    #end
	        
	        #if($chart.LEGEND.y != '')
	        y: $chart.LEGEND.y,
	    	#end
    	
    	#end
        
        #if($chart.LEGEND.style.backgroundColor != '')
        backgroundColor: '$chart.LEGEND.style.backgroundColor',
	    #end
	    
        #if($chart.LEGEND.style.borderWidth != '')
        borderWidth: $chart.LEGEND.style.borderWidth,
	    #end
	    
        shadow: true,
        itemStyle: { 
        	color: '$chart.LEGEND.style.color', 
        	fontSize: '$chart.LEGEND.style.fontSize', 
        	#if ($chart.LEGEND.style.fontWeight == 'italic')
        	fontStyle: 'italic',
        	#elseif ($chart.LEGEND.style.fontWeight == 'underline')
        	textDecoration: 'underline',
        	#else
        	fontWeight: '$chart.LEGEND.style.fontWeight',
        	#end
        }
    },*#

    ## Axes selection
    #set($axisList = $chart.AXES_LIST.AXIS)

    #set($xAxisList = {}) ## X Axises list container
    #set($yAxisList = {}) ## Y Axises list container
    #set($xAxisPositions = {}) ## X Axises integer positions list, for series references
    #set($yAxisPositions = {}) ## Y Axises integer positions list, for series references
    #set($xAxisCounter = 0) 
    #set($yAxisCounter = 0) 
    
    #foreach($axis in $axisList)
	 	#if($axis.type == 'Category')
	 		#set($workAroundNoPrint = $xAxisList.put($axis.alias , $axis))
	 		#set($workAroundNoPrint = $xAxisPositions.put($axis.alias , $xAxisCounter))
	 		
	 		#set($xAxisCounter = $xAxisCounter + 1)
	 	#end
	 	
	 	#if($axis.type == 'Serie')
	 		#if(($chartType == 'radar' && $yAxisCounter < 1) || $chartType != 'radar')
		 		#set($workAroundNoPrint = $yAxisList.put($axis.alias , $axis))
		 		#set($workAroundNoPrint = $yAxisPositions.put($axis.alias , $yAxisCounter))
	 		
		 		#set($yAxisCounter = $yAxisCounter + 1)
	 		#end
	 	#end
	#end
	
    xAxis:
	#foreach($xAxisKey in $xAxisList.keySet())
	 	#set ($xAxis = $xAxisList[$xAxisKey])
	 
	{
	 	title: {
			text: '$xAxis.TITLE.text',
			##y:-150,
			 
			#set ($xTitleAlign = $xAxis.TITLE.style.align)
			#if( $xTitleAlign != '' )
				#if ($xTitleAlign == 'center' )
				align: 'middle',
				#elseif ($xTitleAlign == 'left' )
				align: 'low',
				#elseif ($xTitleAlign == 'right' )
				align: 'high',
				#end
			#end
			 
			style:{
	        	#foreach($styleName in $xAxis.TITLE.style.keySet())
		        	#set ($axisTitleStyle = $xAxis.TITLE.style[$styleName])
		        	#if ($styleName == 'fontWeight' && ($axisTitleStyle == 'italic' || $axisTitleStyle == 'normal'))
	        			fontStyle: '$axisTitleStyle',
					#elseif($styleName == 'fontWeight' && $axisTitleStyle == 'underline')
	        			textDecoration: 'underline',
	        		#elseif($styleName == 'align')
		        			#set($labelAlign=$axisTitleStyle)
					#elseif($axisTitleStyle != '')
	        			$styleName: '$axisTitleStyle',
	        		#end
	        	#end
		    },
		},
		 
		labels:{
		#if( $xAxis.style != '' )
        	style:{
	        	#foreach($styleName in $xAxis.style.keySet())
	        		#set ($axisStyle = $xAxis.style[$styleName])
	        		#if ($styleName == 'fontWeight' && ($axisStyle == 'italic' || $axisStyle == 'normal'))
	        			fontStyle: '$axisStyle',
					#elseif($styleName == 'fontWeight' && $axisStyle == 'underline')
	        			textDecoration: 'underline',
					#elseif($styleName == 'align')
	        			#set($labelAlign=$axisStyle)
	        		#elseif($styleName == 'rotate')
	        			#set($rotation=$axisStyle)		        			
					#else		        			
	        			$styleName: '$axisStyle',
	        		#end
	        	#end
        		},
        		
        		#*
        			If chart's orientation is horizontal, then skip axis label alignment (it will be 
        			predefined one - defined by the Highcharts library), since the label aligned left will 
        			overlap with the title (characteristic of this library). Hence, the value inside 
        			of the combo for alignment of labels on the axis inside of the X-axis panel's Axis 
        			style configuration popup will not be taken into account.
        			
        			@author: danristo (danilo.ristovski@mht.net)
        		*#  
        		#if($labelAlign && ($chart.orientation == 'vertical' || $chartType == "radar"))
        			align: "$labelAlign",
        		#end
        		
        		#if($rotation!="" &&  $rotation!="null")
        			rotation: $rotation,
    			#end
        	#end
		},

		#if($xAxis.position == 'top')
		 	opposite: true,
		#end
		 
		type: 'category',
	},
	#end
    
    
    yAxis: [
        ## Serie add
        #foreach($yAxisKey in $yAxisList.keySet())
        	#set ($yAxis = $yAxisList[$yAxisKey] )
        
        {
        	min: 0,
        	
        	title: {
        		text: '$yAxis.TITLE.text',
        		##x:50,
        		#*
        		#if( $yAxis.style.rotate != '' ) 
        			rotation: $yAxis.style.rotate,
        		#end
        		*#
        		
        		#if( $chartType != "radar" && $yAxis.TITLE.style.align != '' )
        			#if ($yAxis.TITLE.style.align == 'center' )
					align: 'middle',
					#else
					align: '$yAxis.TITLE.style.align',
					#end
				#end
			 
        		style:{
		        	#foreach($styleName in $yAxis.TITLE.style.keySet())
		        		#set ($axisTitleStyle = $yAxis.TITLE.style[$styleName])
		        		#if ($styleName == 'fontWeight' && ($axisTitleStyle == 'italic' || $axisTitleStyle == 'normal'))
		        			fontStyle: '$axisTitleStyle',
						#elseif($styleName == 'fontWeight' && $axisTitleStyle == 'underline')
		        			textDecoration: 'underline',
		        		#elseif($styleName == 'align')
		        			#set($labelAlign=$axisTitleStyle)
						#else		        			
		        			$styleName: '$axisTitleStyle',
		        		#end
		        	#end
        		},
        		
        		#if ($chartType == "radar")
	    			#if($labelAlign=="center" || $labelAlign=="")
	    				align: "middle",
	    			#elseif($labelAlign=="left")
	    				align: "low",
	    			#elseif($labelAlign=="right")
	    				align: "high",
	    			#end   
    			#end   
        	},
        	
        	labels: {
        		
        		## If this parameter is not commented Y-axes labels will be glued to each other when there are no axis titles
        		##x:0,
        	
	    		#if( $yAxis.style != '' ) 
	        		style:{
		        	#foreach($styleName in $yAxis.style.keySet())
		        		#set ($axisStyle = $yAxis.style[$styleName])
		        		#if ($styleName == 'fontWeight' && ($axisStyle == 'italic' || $axisStyle == 'normal'))
		        			fontStyle: '$axisStyle',
						#elseif($styleName == 'fontWeight' && $axisStyle == 'underline')
		        			textDecoration: 'underline',
		        		#elseif($styleName == 'align')
		        			#set($labelAlign=$axisStyle)
		        		#elseif($styleName == 'rotate')
		        			#set($rotation=$axisStyle)
						#else		        			
		        			$styleName: '$axisStyle',
		        		#end
		        	#end
	        		},
	        		
	        		#*
	        			If chart's orientation is vertical, then skip axis label alignment (it will be 
	        			predefined one - defined by the Highcharts library), since the label aligned left 
	        			will overlap with the title (characteristic of this library). Hence, the value inside 
	        			of the combo for alignment of labels on the axis inside of the Y-axis panel's Axis 
	        			style configuration popup will not be taken into account.
	        			
	        			@author: danristo (danilo.ristovski@mht.net)
	        		*# 	        		       		
	        		#if($labelAlign && ($chart.orientation == 'horizontal' || $chartType == "radar"))
	        			align: "$labelAlign",	        		     			
	        		#end
	        		        		
	        		#if($rotation!="" &&  $rotation!="null")
	        			rotation: $rotation,
	    			#end
	    			
	        	#end     		
            },
        	
	        #if($yAxis.MAJORGRID.interval != '')
        	tickInterval: $yAxis.MAJORGRID.interval,
		    #end
		    
	        #if($yAxis.MAJORGRID.style.color != '')
        	gridLineColor: '$yAxis.MAJORGRID.style.color',
		    #end
        	
        	#set($typeline = $yAxis.MAJORGRID.style.typeline)
        	#if($yAxis.MAJORGRID.style.typeline != '')
	        	#if($typeline == 'dashed')
	        		#set($convertedTypeline = 'Dash')
	        	#elseif($typeline == 'dotted')
	        		#set($convertedTypeline = 'Dot')
	    		#elseif($typeline == 'solid')
	        		#set($convertedTypeline = 'Solid')
				#else
	        		#set($convertedTypeline = $typeline)
	        	#end
	        	gridLineDashStyle: '$convertedTypeline',
        	#end
        	
	        #if($yAxis.MINORGRID.interval != '')
        	minorTickInterval: $yAxis.MINORGRID.interval,
		    #end
		    
	        #if($yAxis.MINORGRID.style.color != '')
        	minorGridLineColor: '$yAxis.MINORGRID.style.color',
		    #end
        	
        	#set($typeline = $yAxis.MINORGRID.style.typeline)
        	#if($typeline == 'dashed')
        		#set($convertedMinorTpeline = 'Dash')
    		#elseif($typeline == 'dotted')
        		#set($convertedMinorTpeline = 'Dot')
    		#elseif($typeline == 'solid')
        		#set($convertedMinorTpeline = 'Solid')
        	#end
        	minorGridLineDashStyle: '$convertedMinorTpeline',
        	
        	#if($yAxis.position == 'right')
        	opposite: true,
        	#end
        	
        	stackLabels: {
        		enabled: true
        	},
        },
        #end
        ## FINE Serie add
            
    ],
    
	series: [
	#foreach($valueKey in $seriesMap.keySet())
	    #set($relatedSerie = $seriesMap.get($valueKey))
	    	
	    {	
		#set($relatedSerieColor = false)
		#set($relatedSerieColor = $relatedSerie.color)
		#if($relatedSerieColor && $relatedSerieColor != '')
			color: '$relatedSerieColor',
	    #end
		
			name: '$relatedSerie.name',
		
		#set($relatedSerieType = '')
		#if($relatedSerie.type)
			#set($relatedSerieType = $relatedSerie.type)
		#end
		#if($relatedSerieType != '')
			#if($relatedSerieType == 'bar')
				#set($relatedSerieType = 'column')
			#end		
			#if($relatedSerieType == 'radar')
				#set($relatedSerieType = 'line')
			#end		
	    	type: '$relatedSerieType',
	    #end
	    
	    	## makes the datalabels overlapping
	    	dataLabels: {
	    		allowOverlap: true
	    	},
	    	data: [
	    		#set($relatedSerieColName = "$relatedSerie.column"+"_#if($relatedSerie.groupingFunction)$relatedSerie.groupingFunction#{else}SUM#end")
	    	    #set($serieColumnsMapped = $dataColumnsMapper.get($relatedSerieColName)) ## "Vendite_AVG" -> "column_5" ## "Ricavi_SUM" -> "column_6"
				#foreach($row in $rows)
					#set ($serieValue = $row.get($serieColumnsMapped))
					#set ($serieCategoryName =  $row.get($categorieColumnsMapped))
					{
						##drilldown: $enableDrilldown,
						drilldown: $drilldownEnabledFlag,
						y: $serieValue,
						name: '$serieCategoryName',
						##serieFormatOrPrecision: '$relatedSerie.serieFormatOrPrecision.toLowerCase()',
						
						#if($crossNavigation != '') 
						crossNavigationDocumentName: '$crossNavigation.document',
						crossNavigationDocumentParams: [
							## if single PARAM node, not array
							#if($crossNavigation.PARAM_LIST.PARAM.class.name == "java.util.LinkedHashMap")
								#set($param = $crossNavigation.PARAM_LIST.PARAM)
								{ name: '$param.name', urlName:'$param.parameterUrlName', type: '$param.type', value: '$param.value' }
							#else
								##Array of parameters
								
								#foreach($param in $crossNavigation.PARAM_LIST.PARAM)
								{ name: '$param.name', urlName:'$param.parameterUrlName', type: '$param.type', value: '$param.value' },
								#end
							#end
						],
						#end
						
						#set($relatedSerieShowValue = $relatedSerie.showValue)
						#if ($relatedSerieShowValue != '')
						dataLabels: {
								                    
		                    #*
					    		======================================================================
					    		======================================================================
					    		START: Part of the code that handles whether the data lebels are going to
					    		be presented via the format or via the prefix+precision+postfix.
					    		
					    		@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)
					    		======================================================================
					    		======================================================================
					    	*#
	    	
					    	#set($formatDataLabels = '')
					    	
					    	#*
					    		If the "Show value" option is checked for the particular serie item
					    		the format or prefix+precision+postfix will be shown. The decision
					    		which of those two aspects will be taken is going to be made based
					    		on the value of the "serieFormatOrPrecision" parameter.
					    	*#
					    	#set($relatedSerieShowValue = $relatedSerie.showValue)
					    	#set($relatedSerieFormatOrPrecision = $relatedSerie.serieFormatOrPrecision)				
				
							#if ($relatedSerieShowValue != '')
				                
				                enabled: $relatedSerieShowValue,
				               
				                #*
				                	If the user took the format as the criteria of displaying the
				                	serie value in the belonging data label, take the format that
				                	is specified and simply display value as formatted.
				                	
				                	@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)                	
				                *#
				                #if ($relatedSerieFormatOrPrecision.toLowerCase() == "format")
				                	
				                	#*
				                		If the format string is empty we will take the default 
				                		string that Highcharts API prescribes: '{y}'. 
				                	*#
				                	#if ($relatedSerie.serieFormat == '')
				                		format: '{y}',
				                	#else				                	
						    			format: '$relatedSerie.serieFormat',
					    			#end
						    		
						    	#elseif ($relatedSerieFormatOrPrecision.toLowerCase() == "precision")
						    		
						    		#set ($postfixValueAsString = '')
						    		
						    		#set($emptyPrecision = false)
						    		
						    		#if ($relatedSerie.precision != '')
						    		#end
						    		
					                #if ($relatedSerie.postfixChar != '')
					                    #set ($postfixValueAsString = ' ' + $relatedSerie.postfixChar)
									#end
					                
					                #set ($prefixValueAsString = '')
					                
					                #if ($relatedSerie.prefixChar != '')
					                    #set ($prefixValueAsString = $relatedSerie.prefixChar + ' ')
									#end
					                
					                #set ($precisionValueAsString = '')
					                
					                #*
					                	This is the template for the precision: "{y:,.(x)f}".
					                	
					                	'y:': 		The value of related serie that is going to be presented
					                	',': 		The comma is used for separating thousands in 'y' numeric value.
					                	'.(x)f': 	The precision is used from the configuration user specified.
					                *#
					                #if ($relatedSerie.precision != '')
					                    #set ($precisionValueAsString = ':,.' + $relatedSerie.precision + 'f')
									#end
					                
					                #set ($formatDataLabels = ${prefixValueAsString} + '{y' + $precisionValueAsString + '}' + ${postfixValueAsString})
					                
					                format: '$formatDataLabels',
						    		
						    	#end
				                
							#end    	
					    		  
					    	#*
					    		Commented by Danilo Ristovski
					    		
					    		Take the format of the serie item for their data label
					    	*#  	
					    	#*
						    	#if($relatedSerie.DATA_LABELS.formatDataLabels && $relatedSerie.DATA_LABELS.formatDataLabels != '')
						    		format: '$relatedSerie.DATA_LABELS.formatDataLabels',
						    	#else
						    		format: '$formatDataLabels',
						    	#end
					    	*#	    	
					    	
					    	#*
					    		======================================================================
					    		======================================================================
					    		END: Part of the code that handles whether the data lebels are going to
					    		be presented via the format or via the prefix+precision+postfix.
					    		
					    		Danilo Ristovski
					    		======================================================================
					    		======================================================================
					    	*#
		                }
						#end
					},
				#end
	    	],
	    	
			tooltip: 
			{ 			
				serieFormatOrPrecision: '$relatedSerieFormatOrPrecision.toLowerCase()',
				
				#if ($relatedSerieFormatOrPrecision.toLowerCase() == "format")
	                
		    		format: '$relatedSerie.serieFormat',
			    		
		    	#elseif ($relatedSerieFormatOrPrecision.toLowerCase() == "precision")
			    	
					#set($seriePrefix = $relatedSerie.prefixChar)
					#if($seriePrefix)
						valuePrefix: '$seriePrefix',
					#end
						
					#set($seriePostfix = $relatedSerie.postfixChar)
					#if($seriePostfix)
						valueSuffix: '$seriePostfix',
					#end				
						
					#if ($relatedSerie.precision)
						valueDecimals: '$relatedSerie.precision',
					#end
						
				#end
				
			#*
				If background color for the serie tooltip is not defined (empty)
				take the default value (#FCFFC5) so the tooltip can be readable 
				over the chart that stays behind it. Otherwise, take the value 
				of the background color specified by the user.				
				@author: danristo (danilo.ristovski@mht.net)
			*#
			#if ($relatedSerie.TOOLTIP.backgroundColor!="")
                ttBackColor: '$relatedSerie.TOOLTIP.backgroundColor',
            #else
            	ttBackColor: '#FCFFC5',	## default background color for the serie tooltip
			#end
				
			#if ($relatedSerie.TOOLTIP.style.color != '')
				ttColor: '$relatedSerie.TOOLTIP.style.color' ,
			#end
				
			#if ($relatedSerie.TOOLTIP.style.align != '')
				ttAlign: '$relatedSerie.TOOLTIP.style.align' ,
			#end
				
			#if ($relatedSerie.TOOLTIP.style.fontFamily && $relatedSerie.TOOLTIP.style.fontFamily != '')
				ttFont: '$relatedSerie.TOOLTIP.style.fontFamily' ,
			#end
				
			#if ($relatedSerie.TOOLTIP.style.fontWeight != '')
				ttFontWeight: '$relatedSerie.TOOLTIP.style.fontWeight' ,
			#end
				
			#if ($relatedSerie.TOOLTIP.style.fontSize != '')
				ttFontSize: '$relatedSerie.TOOLTIP.style.fontSize' ,
			#end
			},
		
		#if($chartType != 'radar') 	
    		#set($referencedAxis = $relatedSerie.axis)
    		yAxis: $yAxisPositions[$referencedAxis]
    	#end
	    }, 
	#end
    ],
    
    tooltip: {
        useHTML: true,
        backgroundColor: null,
        borderWidth: 2,
        style: {
            padding: 0
        },
        formatter: function() {
        	var ttColor = this.series.tooltipOptions.ttColor ? this.series.tooltipOptions.ttColor : '';
        	var ttBackColor = this.series.tooltipOptions.ttBackColor ? this.series.tooltipOptions.ttBackColor : '';
        	
        	var ttAlign = this.series.tooltipOptions.ttAlign ? this.series.tooltipOptions.ttAlign : '';
        	var ttFont = this.series.tooltipOptions.ttFont ? ' ' + this.series.tooltipOptions.ttFont : '';
        	var ttFontSize = this.series.tooltipOptions.ttFontSize ? ' ' + this.series.tooltipOptions.ttFontSize : '';
        	var ttFontWeight = this.series.tooltipOptions.ttFontWeight ? ' ' + this.series.tooltipOptions.ttFontWeight : '';
        	       	
        	#*
        		======================================================
        		START: Part of the code that creates the template particular
        		serie item depending on the method used for structuring the
        		data that should be displayed in the tooltip (format or
        		precision).
					    		
	    		Danilo Ristovski
        		======================================================
        	*#
        	       	
        	#*
        		Depending on font style chosen by the user for the serie tooltip
        		we will specify respective CSS attribute so it can be taken by the
        		tooltip.
        		@author: danristo (danilo.ristovski@mht.net)
        	*#
        	var tooltipFontStyle = "";
        	
        	if (ttFontWeight == " underline")
        	{
        		tooltipFontStyle = " text-decoration: underline;";
        	}
        	else if (ttFontWeight == " italic")
        	{
        		tooltipFontStyle = "font-style: italic;";
        	}
        	else if (ttFontWeight == " bold")
        	{
        		tooltipFontStyle = "font-weight: bold;";
        	}
        	else
        	{
        		tooltipFontStyle = "font-weight: normal;";
        	}
	        
	        #*
        		The user is free to choose between two modalities for displaying the
        		serie value: 
        		
        			(1) precision potentially with its prefix and/or postfix: 
        					prefix + serie value with given number of decimals + postfix
        					
        			(2) format string (must follow the Highcharts format):
        					(a) prefix + {y:.(some not negative number)f} + postfix
        					(b) prefix + {point.y:.(some not negative number)f} + postfix
        					
        		@commentBy Danilo Ristovski (danristo, danilo.ristovski@mht.net)
        	*#        	
        	
        	#*
        		=============================
        		CASE: Precision is specified
        		=============================
        		If user specified precision for the serie value potentially with its
        		prefix and/or postfix, take those values in order to construct the 
        		string that will be displayed in the tooltip that appears when mouse
        		is over the particular serie. 
        		
        		@commentBy Danilo Ristovski (danristo, danilo.ristovski@mht.net)
        	*#
        	var valueDecimals = this.series.tooltipOptions.valueDecimals ? this.series.tooltipOptions.valueDecimals : -1;
        	var valuePrefix = this.series.tooltipOptions.valuePrefix ? this.series.tooltipOptions.valuePrefix + ' ' : '';
        	var valueSuffix = this.series.tooltipOptions.valueSuffix ? ' ' + this.series.tooltipOptions.valueSuffix : '';
        	
        	#*
        		=============================
        		CASE: Format is specified
        		=============================
        		If user specified format as modality of the displaying of the serie
        		value, take that string of the format and parse it in order to take
        		all constituents (prefix + separator for thousands + number of decimal 
        		points + postfix). All of those values are optional, but must be defined
        		in a proper way (with valid values) in order to display the tooltip
        		with expected results.
        		
        		@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)        		
        	*#
        	var format = this.series.tooltipOptions.format ? this.series.tooltipOptions.format : '';
        	
        	#*
        		String that will contain which of two modalities the chart is 
        		going to parse and render afterwards: format or precision.
        	*#  
        	var formatOrPrecisionFinal = "";
        	
        	#*
        		Indicator of drilling. If we entered drilling a specific logic
        		should be implemented, since we are lacking of necessary data,
        		in particular of the name of the initial item (category) from
        		which we started drilling.
        	*#  
        	var drilling = false;
        	 
    	 	#*
    	 		If there is/was drilling (if we entered some inner layers).
    	 	*#	        	
        	if (this.series.chart.drilldownLevels && this.series.chart.drilldownLevels.length > 0)
        	{
        		#*
        			All main (root) items (categories) that we had on the initial
        			(first, zeroth) level of the chart.
        		*#
        		var allMainCategories = this.series.chart.drilldownLevels[0].seriesOptions.data;
        		
        		#*
        			The name of the root item from which we started drilling.
        		*#
        		var root = undefined;
        		
        		if (this.series.chart.drilldownLevels.length == 1 || this.series.chart.drilldownLevels.length == 2)
    			{
    				root = this.series.chart.drilldownLevels[0].lowerSeriesOptions.name;
    			}
    			else if (this.series.chart.drilldownLevels.length > 2)
    			{
    				root = this.series.chart.drilldownLevels[1].seriesOptions.name;
    			}
        		
        		#*
        			Find the object that contains property "name" with the value
        			of the "root" variable, so we can extract "dataLabels" property
        			that contains the "format" property.        			
        		*#
        		var resultY = allMainCategories.filter
        		(
        			function(obj) 
        			{
 						 return obj.name == root;
				 	}
				 );
        		
        		if (resultY)
        		{
        			format = resultY[0].dataLabels.format;
        			drilling = true;
        		}
        		
        		#*
        			Since we do not have information about the precision, prefix
        			and postfix for current serie, we can take the "format" value
        			because it is created basing on those three values.
        		*#
        		formatOrPrecisionFinal = "format";
        	}       
        	else
        	{
        		#*
        			If we are not drilling (we are on the initial (root) level of 
        			the chart) take information about the actual modality of 
        			displaying serie item.
        		*#
        		formatOrPrecisionFinal = this.series.tooltipOptions.serieFormatOrPrecision.toLowerCase();
        	} 	
        	
        	#*
        		If the actual modality is format and the format is an empty string,
        		set the default (by the Highcharts library) format so the code can
        		be executed without problem.
        	*#
        	if ( (formatOrPrecisionFinal == "format" && format=="") || 
        			(formatOrPrecisionFinal == "precision" && this.series.tooltipOptions.valueDecimal == "") )
        	{
        		format = "{y}";
        	}
        	
        	#*
        		The value of the serie that is hovered by the mouse.
        	*#
        	var thisValue = this.y;
        	
        	#*
        		Starting construction of the expression that is expected for the format
        		for the value of the serie. There are two possible constructions.
        		
        		@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)
        	*#
        	var onlyYString = "y";
        	var onlyPointYString = "point.y";
        	var yString = "y:";
        	var pointYString = "point.y:";
        	
        	#*
        		The starting and ending index of the expression of the format that is
        		first detected (if there is more than one expression) in the format string.
        		This is extracted for both possible constructions for the format separately. 
        		
        		@author Danilo Ristovski (danristo, danilo.ristovski@mht.net)        		
        	*#
        	var yValueOnlyIndexStart = format.indexOf("{" + onlyYString);
        	var yValueOnlyIndexEnd = format.indexOf("}"); 
        	var pointYValueOnlyIndexStart = format.indexOf("{" + onlyPointYString);
        	var pointYValueOnlyIndexEnd = format.indexOf("}");       	
        	var yValueIndexStart = format.indexOf("{" + yString);
        	var yValueIndexEnd = format.indexOf("}");
        	var pointYValueIndexStart = format.indexOf("{" + pointYString);
        	var pointYValueIndexEnd = format.indexOf("}");
        	        	
        	var prefixText = "";
        	var postfixText = "";  
        	
        	var precision = -1;
        	var separatorOfThousands = "";
        	
        	var pointYValue = "";
        	var yValue = "";
        	
        	#*
        		Predefined decimal point and separator of thousands values in the
        		Highcharts library.
        		
        		@commentBy Danilo Ristovski (danristo, danilo.ristovski@mht.net)
        	*#
        	var decimalPoint = Highcharts.getOptions().lang.decimalPoint,
    			thousandsSep = Highcharts.getOptions().lang.thousandsSep;
        
        	#*
        		This is the way to inspect if there is more than one expression inside the
        		format string for the serie item.
        		
        		@author Danilo Ristovski (danristo, danilo.ristovski@mht.net) 
        	*#
        	//var numberOfDiffPointYFormats = (format.match(new RegExp("{"+pointYString, "g")) || []).length;
        	//var numberOfDiffYFormats = (format.match(new RegExp("{"+yString, "g")) || []).length;        
			//console.log(format.match(new RegExp("{point.y:.([0-9]|[0-2][0-9]$)f", "g")));
			#*
				If the starting part of the construction of the expression within the format 
				of the serie's tooltip is specified via the "point.y:".
				
				@author Danilo Ristovski (danristo, danilo.ristovski@mht.net) 
			*#
			if (pointYValueIndexStart >= 0)
        	{
        		#*
        			Take the whole expression within the format.
        		*#
        		pointYValue = format.substring(pointYValueIndexStart, pointYValueIndexEnd+1);
        		
        		#*
        			Take the pure content of the expression - the format itself.
        		*#
        		var formatPure = pointYValue.substring(pointYString.length+1,pointYValue.length-1); 
        		
        		#*
        			Extract the precision (number of decimal points) from this string.
        		*#
        		if(formatPure.indexOf(decimalPoint)>=0 && formatPure.indexOf("f")>=0)
        		{
        			precision = formatPure.substring(formatPure.indexOf(decimalPoint)+1,formatPure.indexOf("f"));
        		}
        		
        		#*
        			Inspect if there is thousands separator within the expression.
        		*#
        		if(formatPure.indexOf(thousandsSep)>=0)
        		{
        			separatorOfThousands = thousandsSep;
        		}
        		
        		#*
        			Extract the prefix text and the postfix text from the whole format string.
        		*#
        		prefixText = format.substring(0,pointYValueIndexStart);
        		postfixText = format.substring(pointYValueIndexEnd+1,format.length);
        	}
        	
        	#*
				If the starting part of the construction of the expression within the format 
				of the serie's tooltip is specified via the "y:".
				
				@author Danilo Ristovski (danristo, danilo.ristovski@mht.net) 
			*#
        	else if (yValueIndexStart >= 0)
        	{
        		yValue = format.substring(yValueIndexStart, yValueIndexEnd+1);
        		
        		var formatPure = yValue.substring(yString.length+1,yValue.length-1);     
        		
        		if(formatPure.indexOf(decimalPoint)>=0 && formatPure.indexOf("f")>=0)
        		{
        			precision = formatPure.substring(formatPure.indexOf(decimalPoint)+1,formatPure.indexOf("f"));
        		}
        		
        		if(formatPure.indexOf(thousandsSep)>=0)
        		{
        			separatorOfThousands = thousandsSep;
        		}
        		
        		prefixText = format.substring(0,yValueIndexStart);
        		postfixText = format.substring(yValueIndexEnd+1,format.length);
        	}
        	
        	else if (yValueOnlyIndexStart >= 0)
        	{
        		//yValue = format.substring(yValueOnlyIndexStart, yValueOnlyIndexEnd+1);
        		
        		#*
        		var formatPure = yValue.substring(yString.length+1,yValue.length-1);     
        		
        		if(formatPure.indexOf(decimalPoint)>=0 && formatPure.indexOf("f")>=0)
        		{
        			precision = formatPure.substring(formatPure.indexOf(decimalPoint)+1,formatPure.indexOf("f"));
        		}
        		
        		if(formatPure.indexOf(thousandsSep)>=0)
        		{
        			separatorOfThousands = thousandsSep;
        		}
        		*#
        		
        		prefixText = format.substring(0,yValueOnlyIndexStart);
        		postfixText = format.substring(yValueOnlyIndexEnd+1,format.length);
        	}
        	
        	else if (pointYValueOnlyIndexStart >= 0)
        	{
        		prefixText = format.substring(0,pointYValueOnlyIndexStart);
        		postfixText = format.substring(pointYValueOnlyIndexEnd+1,format.length);
        	}
        	#*
        		There is no expression for serie (y, y:, point.y)
        	*#
        	else
        	{
        		prefixText = format.substring(0,format.length);
        		postfixText = "";
        	}
        	
        	#*
        		Construct the final string for the serie tooltip depending on the user's 
        		choice on the modality of the display of the serie value in the tolltip - 
        		whether it is the Format or Precision (plus prefix/postfix). The if-part
        		is handling the case when the "Precision" is used.
        	*#          	
        	if (formatOrPrecisionFinal == "precision" && !drilling)
        	{
	        	if(valueDecimals > -1 ) 
	        	{
	        		thisValue = Highcharts.numberFormat(thisValue, valueDecimals, decimalPoint, thousandsSep);
	        	}
	        	
	        	thisValue = valuePrefix + thisValue + valueSuffix;
        	}
        	else if (formatOrPrecisionFinal == "format" || drilling)
        	{    
    			#*
    				In those three cases we are dealing with the pure serie value (without any
    				kind of formatting, since this is the default behavior within the Highcharts
    				library.
    			*#
    			if ( format != "" 
    					&& format != ("{" + onlyYString + "}") 
    							&& format != ("{" + onlyPointYString + "}") )
    			{
    				if (format.indexOf("{" + yString)>=0 || format.indexOf("{" + pointYString)>=0)
					{											
						if (precision >= 0)
		    			{				
		    				thisValue = Highcharts.numberFormat(thisValue, precision, decimalPoint, separatorOfThousands);    				
		    				thisValue = prefixText+thisValue+postfixText;
		    			}
		    			else
		    			{
		    				thisValue = prefixText + " " + postfixText;
		    			}
					}
    				else if (format.indexOf("{" + onlyYString + "}")>=0 || format.indexOf("{" + onlyPointYString + "}")>=0)
    				{
    					precision = 0;	// Highcharts default
    					thisValue = Highcharts.numberFormat(thisValue, precision, decimalPoint, separatorOfThousands);
	    				thisValue = prefixText+thisValue+postfixText;
    				}
    				else
    				{
    					thisValue = prefixText+postfixText;
    				}
    			}
        	}
        	
        	#*
        		======================================================
        		END: Part of the code that creates the template particular
        		serie item depending on the method used for structuring the
        		data that should be displayed in the tooltip (format or
        		precision).
					    		
	    		Danilo Ristovski
        		======================================================
        	*#
        	
        	#*
        		Separate font elements (family, size and weight (style)) so the tooltip
        		font characteristics can be separately (independently) specified by the user.
        		@modifiedBy: danristo (danilo.ristovski@mht.net)
        	*#
            var result = 
            	'<div style="padding:10px;color:' + ttColor + '; opacity: 0.9; background:' + ttBackColor + ';' + " font-family: " + ttFont + "; "
            					+ tooltipFontStyle + " font-size: " + ttFontSize + ';text-align:' + ttAlign + ';">'; 
            
            #*
        		Removed bold font style (weight) as default one for the serie value, since
        		style of the fonts on the tooltip will be the same for every single font
        		element on it. HTML tag <strong> is removed.
        		@modifiedBy: danristo (danilo.ristovski@mht.net)
        	*#
            result += '<span>' + this.key + '</span><br/>' + this.series.name + ': ' + thisValue + '</div>';
            return result;
        }
    },
    
    #if($enableDrilldown)
    drilldown: {
        series: []
    },
    #end
    
    lang: {
        noData: '$chart.EMPTYMESSAGE.text'
    },
    noData: {
    	style:{
    	#foreach($styleName in $chart.EMPTYMESSAGE.style.keySet())
    		$styleName: '$chart.EMPTYMESSAGE.style[$styleName]',
    	#end
		}
    },
    
    credits: { ##remove bottom credits text
    	enabled: false
    },
    
    plotOptions: {
        line: {
	        marker: {
                symbol: 'circle',
                lineWidth: 2
            }
        },
        #if($chart.isCockpitEngine == 'true' && $chart.outcomingEventsEnabled == 'true')
        series: {
            cursor: 'pointer',
            point: {
                events: {
                    click: handleCockpitSelection
                }
            },
            
            #* 
            	From Highcharts API: When a series contains a data array that is longer than this, 
            	only one dimensional arrays of numbers, or two dimensional arrays with x and y values 
            	are allowed. Also, only the first point is tested, and the rest are assumed to be the 
            	same format. This saves expensive data checking and indexing in long series. Set it to 
            	0 disable. Defaults to 1000.
            	
            	URL: http://api.highcharts.com/highcharts#plotOptions.series.turboThreshold
            	
            	We will increase this value in order to display series that contain a data array bigger
            	than 1000 (default), because it is most likely that we will have this situation very 
            	often.
            	
            	@author: danristo (danilo.ristovski@mht.net)
            *#
            turboThreshold: 5000
        }
        #end
    }
}